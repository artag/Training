# Часть II. Высококачественный код

## Глава 5. Проектирование при конструировании

### 5.1. Проблемы, связанные с проектированием ПО

**Проектирование ПО** - разработка или изобретение схемы преобразования спецификации приложения
в готовое приложение.

Проектирование — процесс, который связывает выработку требований с кодированием и отладкой.

С проектированием связано множество проблем — их-то мы и обсудим.

#### Проектирование — «грязная» проблема

"Грязная" проблема - это проблема, которую можно ясно определить только путем полного или
частичного решения.

По сути данный парадокс подразумевает, что проблему нужно «решить» один раз, чтобы получить ее
ясное определение, а затем еще раз для создания работоспособного решения.

Очень часто бывает, что только решив проблему можно обнаружить дополнительный аспект проблемы.

#### Проектирование - неряшливый процесс (даже если оно приводит к аккуратному результату)

Проектирование неряшливо потому что:
* Вы выполняете много неверных действий и попадаете во множество тупиков, т. е. совершаете массу
ошибок. Ошибки являются сутью проектирования: дешевле допустить ошибки и исправить проект программы,
чем найти их после кодирования и исправлять готовый код.

* Удачное решение часто лишь чуть-чуть отличается от неудачного.

* Трудно узнать, когда проект «достаточно хорош». (Чаще всего отвечают: «Когда у вас вышло время»).

#### Проектирование связано с определением компромиссов и приоритетов

Анализ конкурирующих характеристик проекта и достижение баланса между ними (быстродействие,
занимаемый объем, скорость разработки, ...).

#### Проектирование подразумевает ограничение возможностей

Ограниченные объемы ресурсов при проектировании ПО зданий требуют упрощения решения, что в итоге
приводит к его улучшению.

#### Проектирование — недетерминированный процесс

Спроектировать компьютерную программу можно десятками разных способов.

#### Проектирование — эвристический процесс

* Методы проектирования являются эвристическими методами, т. е. «практическими правилами» или
«способами, которые могут сработать», а не воспроизводимыми процессами.

* Проектирование — метод проб и ошибок.

* Инструменты или методы проектирования, оказавшиеся эффективными в одном случае, в другой ситуации
могут оказаться куда менее эффективными.

* Универсальных методик проектирования не существует.

#### Проектирование — постепенный процесс

Проекты приложений не возникают сразу в готовом виде. Они развиваются и улучшаются в ходе обзоров,
неформальных обсуждений, написания кода и выполнения его ревизий.
Практически во всех случаях проект несколько меняется во время первоначальной разработки системы и
еще больше — при ее модернизации.

### 5.2. Основные концепции проектирования

#### Главный Технический Императив Разработки ПО: управление сложностью

##### Существенные и несущественные проблемы

Cложность разработки ПО объясняется **существенными** и **несущественными** проблемами.

**Cущественными** называют свойства, которыми объект должен обладать, чтобы быть именно этим
объектом.

**Несущественными** (второстепенными, произвольными, необязательными и случайными) свойствами
называют свойства, которыми объект обладает в силу случайности, — свойства, не влияющие на его суть.

Многие несущественные проблемы разработки ПО уже давно решены: синтаксис языков программирования,
среды разработки, многозадачные ОС, ...

Решение оставшихся существенных проблем разработки ПО все более медленное: разработчики ПО берутся
за решение все более серьезных проблем реального мира, им приходится анализировать все
более сложные взаимодействия между сущностями.

##### Важность управления сложностью

Управление сложностью — самый важный технический аспект разработки ПО.

Ни один человек не обладает интеллектом, способным вместить все детали современного ПО. Надо
организовать программы так, чтобы можно было безопасно работать с их отдельными фрагментами по
очереди. Целью этого является минимизация объема программы, о котором нужно думать в конкретный
момент времени.

На уровне архитектуры ПО сложность проблемы можно снизить разделив систему на подсистемы.

В разбиении сложной проблемы на простые фрагменты и заключается цель всех методик проектирования ПО.

##### Как бороться со сложностью?

Чаще всего причинами неэффективности являются:
* сложное решение простой проблемы;
* простое, но неверное решение сложной проблемы;
* неадекватное сложное решение сложной проблемы;

Двойственный подход к управлению сложностью:

* старайтесь свести к минимуму объем существенной сложности, с которым придется работать в каждый
конкретный момент времени;

* сдерживайте необязательный рост несущественной сложности;

#### Желательные характеристики проекта

**Минимальная сложность**

* Избегайте создания «хитроумных» проектов.

* Если при работе над отдельным фрагментом программы проект не позволяет безопасно игнорировать
большинство остальных фрагментов, он неудачен.

**Простота сопровождения**

Проектируя приложение, не забывайте о программистах, которые будут его сопровождать.

**Слабое сопряжение (loose coupling)**

Слабое сопряжение (loose coupling) сводит к минимуму числа соединений между разными частями
программы. Для проектирования классов с минимальным числом взаимосвязей используйте принципы
адекватной абстракции интерфейсов, инкапсуляцию и сокрытие информации.

Это позволит максимально облегчить интеграцию, тестирование и сопровождение программы.

**Расширяемость**

Расширяемость системы позволяет улучшать систему, не нарушая ее основной структуры.
Изменение одного фрагмента системы не должно влиять на ее другие фрагменты.

**Возможность повторного использования**

Проектируйте систему так, чтобы ее фрагменты можно было повторно использовать в других системах.

**Высокий коэффициент объединения по входу (fan-in)**

К конкретному классу обращается большое число других классов.
Это значит, что система предусматривает интенсивное использование вспомогательных низкоуровневых классов.

**Низкий или средний коэффициент разветвления по выходу (fan-out)**

Конкретный класс обращается к малому или среднему числу других классов.
Высокий fan-out **более семи** говорит о том, что класс использует большое число других классов и,
возможно, слишком сложен.

**Портируемость**

Проектируйте систему так, чтобы ее можно было легко адаптировать к другой среде.

**Минимальная, но полная функциональность**

Отсутствие в системе лишних частей.

**Стратификация**

Разделение уровней декомпозиции, позволяющее изучить систему на любом отдельном уровне и
получить при этом согласованное представление. Проектируйте систему так, чтобы ее можно
было изучать на отдельных уровнях, игнорируя другие уровни.

Пример: система, которая должна использовать большой объем старого, плохо спроектированного кода.
Можно написать уровень, отвечающий за взаимодействие со старым кодом, который будет предоставлять
более новым уровням согласованный набор сервисов.

Пусть остальные части системы работают с этими классами вместо старого кода. Преимущества:
1) изоляция плохого кода и 2) при выбраывании старого кода или его рефакторинге, не придется
изменять новый код за исключением промежуточного уровня.

**Соответствие стандартным методикам**

Применять стандартные популярные подходы.

#### Уровни проектирования

1. Система
2. Разделение системы на подсистемы/пакеты
3. Разделение пакетов на классы
4. Разделение классов на данные и методы
5. Проектирование методов

**Уровень 1: программная система**

**Уровень 2: разделение системы на подсистемы или пакеты**

*При работе над совсем небольшим проектом этот уровень проектирования можно пропустить.*

Главный результат проектирования на этом уровне — определение основных подсистем.

Подсистемы могут быть довольно крупными: модуль работы с БД, модули GUI,
бизнес-правил или создания отчетов, интерпретатор команд и т. д.

Суть проектирования на данном уровне заключается в разделении программы на основные подсистемы и
определении взаимодействий между подсистемами.

Важный аспект этого уровня — определение правил взаимодействия подсистем.

Примеры решаемых вопросов:

* в скольких разных частях системы нужно хоть немного разбираться разработчику, желающему изменить
какой-то аспект подсистемы графических операций?

* что будет, если вы попытаетесь задействовать данный модуль бизнес-правил в другой системе?

* что будет, если вы захотите включить в систему новый пользовательский интерфейс?

* что произойдет, если вы захотите перенести модуль хранения данных на удаленный компьютер?

Архитектура системы должна быть такой, чтобы замена подсистем требовала как можно меньше возни
со связями между ними (приводится аналогия со шлангами).

* Организация коммуникации между подсистемами на основе принципа «необходимого знания».

* Стремиться к простоте отношений между подсистемами:
  * (Самая простая) Одна подсистема вызывает методы другой.
  * (Сложнее) Одна подсистема содержит классы другой.
  * (Самая сложная) Наследование классов одной подсистемы от классов другой

* Программа не должна содержать циклических отношений (A -> B -> C -> A).

Пример часто используемых подсистем:

1. *Подсистема бизнес-правил* - законы, директивы, политики и процедуры, реализуемые в компьютерной
системе.

2. *Подсистема пользовательского интерфейса*.

3. *Подсистема доступа к БД*.

4. *Подсистема изоляции зависимостей от ОС*. (Облегечение возможного портирования на другую ОС).

**Уровень 3: разделение подсистем на классы**

Этот уровень проектирования предполагает определение всех классов системы.

Сутью проектирования на данном уровне является декомпозиция подсистем до такого уровня детальности,
который позволит реализовать части подсистем в форме отдельных классов.

На этом уровне следует определить детали взаимодействия каждого класса с остальными элементами
системы, особенно интерфейс класса.

Например, подсистема доступа к БД может быть далее разделена на классы доступа к данным и
классы хранения данных, а также метаданные БД.

**Уровень 4: разделение классов на методы**

*Часто выполняется отдельными программистами*

Данный уровень проектирования заключается в разделении каждого класса на
методы.

Некоторые методы уже будут определены на уровне 3, при проектировании интерфейсов классов.

На уровне 4 вы детально определите закрытые методы классов. Полное определение методов класса часто
позволяет лучше понять его интерфейс, что может подтолкнуть к соответствующему изменению интерфейса,
т. е. к возвращению на уровень 3.

**Уровень 5: проектирование методов**

*Обычно выполняется отдельными программистами*

### 5.3. Компоненты проектирования: эвристические принципы

*Набор рекомендаций, т.к. процесс проектирования недетерминирован.*

#### Определите объекты реального мира

Самый популярный, подход к проектированию основан на определении объектов реального мира и
искусственных объектов.

Определяются:
* объекты и их атрибуты (методы и данные);
* действия, которые могут быть выполнены над каждым объектом;
* действия, которые каждый объект может выполнять над другими объектами;
* части каждого объекта, видимые другим объектам, т. е. открытые и закрытые части;
* открытый интерфейс каждого объекта;

**Определите объекты и их атрибуты**

Каждый объект имеет характеристики, релевантные для компьютерной программы.

**Определите действия, которые могут быть выполнены над каждым объектом**

Объекты могут поддерживать самые разные операции.

**Определите действия, которые каждый объект может выполнять над другими объектами**

Двумя универсальными действиями, которые объекты могут выполнять друг над другом, являются
**включение** (containment) и **наследование**.

**Определите части каждого объекта, видимые другим объектам**

Определение частей объекта, которые следует сделать открытыми, и частей, которые следует держать
закрытыми (требуется для данных и методов).

**Определите интерфейс каждого объекта**

* *Открытый интерфейс* - данные и методы, которые объект предоставляет в распоряжение
остальным объектам.

* *Защищенный интерфейс* - части объекта, доступные только производным от него объектам.

#### Определите согласованные абстракции

Абстракция позволяет задействовать концепцию, игнорируя ее некоторые детали и работая с разными
деталями на разных уровнях.

Удачный интерфейс класса — это абстракция, позволяющая сосредоточиться на интерфейсе,
не беспокоясь о внутренних механизмах работы класса.

Абстракции на уровне интерфейсов методов, интерфейсов классов и интерфейсов пакетов.

#### Инкапсулируйте детали реализации

Инкапсуляция помогает управлять сложностью, блокируя доступ к ней. (Скрытие тонкостей реализации).

#### Используйте наследование, если оно упрощает проектирование

Очень часто одни объекты аналогичны другим за исключением нескольких различий.
Определение сходств и различий между такими объектами называется «наследованием».

#### Скрывайте секреты (к вопросу о сокрытии информации)

Сокрытие информации оказывается особенно мощным эвристическим принципом, так как все его
аспекты и даже само название подчеркивают сокрытие сложности.

Один из важнейших аспектов проектирования класса — принятие решения о том, какие свойства сделать
доступными вне класса, а какие оставить секретными.

Класс может использовать несколько типов данных, не раскрывая сведений о них.

Интерфейс класса должен сообщать как можно меньше о внутренней работе класса.

**Две категории секретов**

* секреты, которые скрывают сложность, позволяя программистам забыть о ней при работе над
остальными частями программы. (сложные типы данных, файловые структуры, булевы тесты,
запутанные алгоритмы)

* секреты, которые скрывают источники изменений с целью локализации результатов возможных изменений.

