# Часть II. Высококачественный код

## Глава 5. Проектирование при конструировании

### 5.1. Проблемы, связанные с проектированием ПО

**Проектирование ПО** - разработка или изобретение схемы преобразования спецификации приложения
в готовое приложение.

Проектирование — процесс, который связывает выработку требований с кодированием и отладкой.

С проектированием связано множество проблем — их-то мы и обсудим.

#### Проектирование — «грязная» проблема

"Грязная" проблема - это проблема, которую можно ясно определить только путем полного или
частичного решения.

По сути данный парадокс подразумевает, что проблему нужно «решить» один раз, чтобы получить ее
ясное определение, а затем еще раз для создания работоспособного решения.

Очень часто бывает, что только решив проблему можно обнаружить дополнительный аспект проблемы.

#### Проектирование - неряшливый процесс (даже если оно приводит к аккуратному результату)

Проектирование неряшливо потому что:
* Вы выполняете много неверных действий и попадаете во множество тупиков, т. е. совершаете массу
ошибок. Ошибки являются сутью проектирования: дешевле допустить ошибки и исправить проект программы,
чем найти их после кодирования и исправлять готовый код.

* Удачное решение часто лишь чуть-чуть отличается от неудачного.

* Трудно узнать, когда проект «достаточно хорош». (Чаще всего отвечают: «Когда у вас вышло время»).

#### Проектирование связано с определением компромиссов и приоритетов

Анализ конкурирующих характеристик проекта и достижение баланса между ними (быстродействие,
занимаемый объем, скорость разработки, ...).

#### Проектирование подразумевает ограничение возможностей

Ограниченные объемы ресурсов при проектировании ПО зданий требуют упрощения решения, что в итоге
приводит к его улучшению.

#### Проектирование — недетерминированный процесс

Спроектировать компьютерную программу можно десятками разных способов.

#### Проектирование — эвристический процесс

* Методы проектирования являются эвристическими методами, т. е. «практическими правилами» или
«способами, которые могут сработать», а не воспроизводимыми процессами.

* Проектирование — метод проб и ошибок.

* Инструменты или методы проектирования, оказавшиеся эффективными в одном случае, в другой ситуации
могут оказаться куда менее эффективными.

* Универсальных методик проектирования не существует.

#### Проектирование — постепенный процесс

Проекты приложений не возникают сразу в готовом виде. Они развиваются и улучшаются в ходе обзоров,
неформальных обсуждений, написания кода и выполнения его ревизий.
Практически во всех случаях проект несколько меняется во время первоначальной разработки системы и
еще больше — при ее модернизации.

### 5.2. Основные концепции проектирования

#### Главный Технический Императив Разработки ПО: управление сложностью

##### Существенные и несущественные проблемы

Cложность разработки ПО объясняется **существенными** и **несущественными** проблемами.

**Cущественными** называют свойства, которыми объект должен обладать, чтобы быть именно этим
объектом.

**Несущественными** (второстепенными, произвольными, необязательными и случайными) свойствами
называют свойства, которыми объект обладает в силу случайности, — свойства, не влияющие на его суть.

Многие несущественные проблемы разработки ПО уже давно решены: синтаксис языков программирования,
среды разработки, многозадачные ОС, ...

Решение оставшихся существенных проблем разработки ПО все более медленное: разработчики ПО берутся
за решение все более серьезных проблем реального мира, им приходится анализировать все
более сложные взаимодействия между сущностями.

##### Важность управления сложностью

Управление сложностью — самый важный технический аспект разработки ПО.

Ни один человек не обладает интеллектом, способным вместить все детали современного ПО. Надо
организовать программы так, чтобы можно было безопасно работать с их отдельными фрагментами по
очереди. Целью этого является минимизация объема программы, о котором нужно думать в конкретный
момент времени.

На уровне архитектуры ПО сложность проблемы можно снизить разделив систему на подсистемы.

В разбиении сложной проблемы на простые фрагменты и заключается цель всех методик проектирования ПО.

##### Как бороться со сложностью?

Чаще всего причинами неэффективности являются:
* сложное решение простой проблемы;
* простое, но неверное решение сложной проблемы;
* неадекватное сложное решение сложной проблемы;

Двойственный подход к управлению сложностью:

* старайтесь свести к минимуму объем существенной сложности, с которым придется работать в каждый
конкретный момент времени;

* сдерживайте необязательный рост несущественной сложности;

#### Желательные характеристики проекта

**Минимальная сложность**

* Избегайте создания «хитроумных» проектов.

* Если при работе над отдельным фрагментом программы проект не позволяет безопасно игнорировать
большинство остальных фрагментов, он неудачен.

**Простота сопровождения**

Проектируя приложение, не забывайте о программистах, которые будут его сопровождать.

**Слабое сопряжение (loose coupling)**

Слабое сопряжение (loose coupling) сводит к минимуму числа соединений между разными частями
программы. Для проектирования классов с минимальным числом взаимосвязей используйте принципы
адекватной абстракции интерфейсов, инкапсуляцию и сокрытие информации.

Это позволит максимально облегчить интеграцию, тестирование и сопровождение программы.

**Расширяемость**

Расширяемость системы позволяет улучшать систему, не нарушая ее основной структуры.
Изменение одного фрагмента системы не должно влиять на ее другие фрагменты.

**Возможность повторного использования**

Проектируйте систему так, чтобы ее фрагменты можно было повторно использовать в других системах.

**Высокий коэффициент объединения по входу (fan-in)**

К конкретному классу обращается большое число других классов.
Это значит, что система предусматривает интенсивное использование вспомогательных низкоуровневых классов.

**Низкий или средний коэффициент разветвления по выходу (fan-out)**

Конкретный класс обращается к малому или среднему числу других классов.
Высокий fan-out **более семи** говорит о том, что класс использует большое число других классов и,
возможно, слишком сложен.

**Портируемость**

Проектируйте систему так, чтобы ее можно было легко адаптировать к другой среде.

**Минимальная, но полная функциональность**

Отсутствие в системе лишних частей.

**Стратификация**

Разделение уровней декомпозиции, позволяющее изучить систему на любом отдельном уровне и
получить при этом согласованное представление. Проектируйте систему так, чтобы ее можно
было изучать на отдельных уровнях, игнорируя другие уровни.

Пример: система, которая должна использовать большой объем старого, плохо спроектированного кода.
Можно написать уровень, отвечающий за взаимодействие со старым кодом, который будет предоставлять
более новым уровням согласованный набор сервисов.

Пусть остальные части системы работают с этими классами вместо старого кода. Преимущества:
1) изоляция плохого кода и 2) при выбраывании старого кода или его рефакторинге, не придется
изменять новый код за исключением промежуточного уровня.

**Соответствие стандартным методикам**

Применять стандартные популярные подходы.

#### Уровни проектирования

1. Система
2. Разделение системы на подсистемы/пакеты
3. Разделение пакетов на классы
4. Разделение классов на данные и методы
5. Проектирование методов

**Уровень 1: программная система**

**Уровень 2: разделение системы на подсистемы или пакеты**

*При работе над совсем небольшим проектом этот уровень проектирования можно пропустить.*

Главный результат проектирования на этом уровне — определение основных подсистем.

Подсистемы могут быть довольно крупными: модуль работы с БД, модули GUI,
бизнес-правил или создания отчетов, интерпретатор команд и т. д.

Суть проектирования на данном уровне заключается в разделении программы на основные подсистемы и
определении взаимодействий между подсистемами.

Важный аспект этого уровня — определение правил взаимодействия подсистем.

Примеры решаемых вопросов:

* в скольких разных частях системы нужно хоть немного разбираться разработчику, желающему изменить
какой-то аспект подсистемы графических операций?

* что будет, если вы попытаетесь задействовать данный модуль бизнес-правил в другой системе?

* что будет, если вы захотите включить в систему новый пользовательский интерфейс?

* что произойдет, если вы захотите перенести модуль хранения данных на удаленный компьютер?

Архитектура системы должна быть такой, чтобы замена подсистем требовала как можно меньше возни
со связями между ними (приводится аналогия со шлангами).

* Организация коммуникации между подсистемами на основе принципа «необходимого знания».

* Стремиться к простоте отношений между подсистемами:
  * (Самая простая) Одна подсистема вызывает методы другой.
  * (Сложнее) Одна подсистема содержит классы другой.
  * (Самая сложная) Наследование классов одной подсистемы от классов другой

* Программа не должна содержать циклических отношений (A -> B -> C -> A).

Пример часто используемых подсистем:

1. *Подсистема бизнес-правил* - законы, директивы, политики и процедуры, реализуемые в компьютерной
системе.

2. *Подсистема пользовательского интерфейса*.

3. *Подсистема доступа к БД*.

4. *Подсистема изоляции зависимостей от ОС*. (Облегечение возможного портирования на другую ОС).

**Уровень 3: разделение подсистем на классы**

Этот уровень проектирования предполагает определение всех классов системы.

Сутью проектирования на данном уровне является декомпозиция подсистем до такого уровня детальности,
который позволит реализовать части подсистем в форме отдельных классов.

На этом уровне следует определить детали взаимодействия каждого класса с остальными элементами
системы, особенно интерфейс класса.

Например, подсистема доступа к БД может быть далее разделена на классы доступа к данным и
классы хранения данных, а также метаданные БД.

**Уровень 4: разделение классов на методы**

*Часто выполняется отдельными программистами*

Данный уровень проектирования заключается в разделении каждого класса на
методы.

Некоторые методы уже будут определены на уровне 3, при проектировании интерфейсов классов.

На уровне 4 вы детально определите закрытые методы классов. Полное определение методов класса часто
позволяет лучше понять его интерфейс, что может подтолкнуть к соответствующему изменению интерфейса,
т. е. к возвращению на уровень 3.

**Уровень 5: проектирование методов**

*Обычно выполняется отдельными программистами*

### 5.3. Компоненты проектирования: эвристические принципы

*Набор рекомендаций, т.к. процесс проектирования недетерминирован.*

#### Определите объекты реального мира

Самый популярный, подход к проектированию основан на определении объектов реального мира и
искусственных объектов.

Определяются:
* объекты и их атрибуты (методы и данные);
* действия, которые могут быть выполнены над каждым объектом;
* действия, которые каждый объект может выполнять над другими объектами;
* части каждого объекта, видимые другим объектам, т. е. открытые и закрытые части;
* открытый интерфейс каждого объекта;

**Определите объекты и их атрибуты**

Каждый объект имеет характеристики, релевантные для компьютерной программы.

**Определите действия, которые могут быть выполнены над каждым объектом**

Объекты могут поддерживать самые разные операции.

**Определите действия, которые каждый объект может выполнять над другими объектами**

Двумя универсальными действиями, которые объекты могут выполнять друг над другом, являются
**включение** (containment) и **наследование**.

**Определите части каждого объекта, видимые другим объектам**

Определение частей объекта, которые следует сделать открытыми, и частей, которые следует держать
закрытыми (требуется для данных и методов).

**Определите интерфейс каждого объекта**

* *Открытый интерфейс* - данные и методы, которые объект предоставляет в распоряжение
остальным объектам.

* *Защищенный интерфейс* - части объекта, доступные только производным от него объектам.

#### Определите согласованные абстракции

Абстракция позволяет задействовать концепцию, игнорируя ее некоторые детали и работая с разными
деталями на разных уровнях.

Удачный интерфейс класса — это абстракция, позволяющая сосредоточиться на интерфейсе,
не беспокоясь о внутренних механизмах работы класса.

Абстракции на уровне интерфейсов методов, интерфейсов классов и интерфейсов пакетов.

#### Инкапсулируйте детали реализации

Инкапсуляция помогает управлять сложностью, блокируя доступ к ней. (Скрытие тонкостей реализации).

#### Используйте наследование, если оно упрощает проектирование

Очень часто одни объекты аналогичны другим за исключением нескольких различий.
Определение сходств и различий между такими объектами называется «наследованием».

#### Скрывайте секреты (к вопросу о сокрытии информации)

Сокрытие информации оказывается особенно мощным эвристическим принципом, так как все его
аспекты и даже само название подчеркивают сокрытие сложности.

Один из важнейших аспектов проектирования класса — принятие решения о том, какие свойства сделать
доступными вне класса, а какие оставить секретными.

Класс может использовать несколько типов данных, не раскрывая сведений о них.

Интерфейс класса должен сообщать как можно меньше о внутренней работе класса.

**Две категории секретов**

* секреты, которые скрывают сложность, позволяя программистам забыть о ней при работе над
остальными частями программы. (сложные типы данных, файловые структуры, булевы тесты,
запутанные алгоритмы, ...)

* секреты, которые скрывают источники изменений с целью локализации результатов возможных изменений.

**Барьеры, препятствующие сокрытию информации**

* **Избыточное распространение информации**

    Примеры:
    * магическое число, которое используется в нескольких местах программы.
    * распределение взаимодействия с пользователями по разным местам в программе.
    * глобальный "необернутый" элемент данных (например, массив).

* **Круговая зависимость**

    Метод класса A вызывает метод класса B, а метод B вызывает метод класса A.

* **Ошибочное представление о данных класса как о глобальных данных**

    Недостатки глобальных данных:
    * методы, обращающиеся к глобальным данным, не знают о том, что другие методы тоже
    обращаются к этим данным.
    * методы не знают, что именно другие методы делают с глобальными данными.

* **Кажущееся снижение производительности**

**Важность сокрытия информации**

Размышление о том, что скрыть, способствует принятию удачных решений на всех уровнях проектирования.

#### Определите области вероятных изменений

1. Определите элементы, изменение которых кажется вероятным.
2. Отделите элементы, изменение которых кажется вероятным.
3. Изолируйте элементы, изменение которых кажется вероятным.

Несколько областей, которые меняются чаще всего (что лучше изолировать):
* Бизнес правила
* Зависимости от оборудования
* Ввод-вывод (формат файлов, формат и вид данных, ...)
* Нестандартные возможности языка
* Сложные аспекты проектирования и конструирования
* Переменные статуса
    * В качестве переменных статуса примениять перечисления.
    * Вместо непосредственной проверки переменной используйте методы доступа.
* Размеры структур данных (например, длину массива задать с помощью именованной константы).

**Предвосхищение изменений разного масштаба**

Совет. Примерная последовательность шагов для определения мест с вероятными изменениями:
1. Определить минимальное подмножество фрагментов программы, необходимых пользователям (**ядро системы**).
2. Мнимальные инкрементные приращения системы.
    * Функциональные изменения
    * Качественные изменения (обеспечение безопасности в многопоточной среде,
    поддержка механизмов локализации, ...)

Минимальные приразения вероятнее всего будут наиболее часто изменяемы.

#### Поддерживайте сопряжение слабым (loose coupling)

* Цель — создать классы и методы, имеющие немногочисленные, непосредственные, явные и
гибкие отношения с другими классами.

* Сопряжение модулей должно быть достаточно слабым, чтобы одни модули могли с легкостью
использовать другие.

* Старайтесь создавать модули, слабо зависящие от других модулей.

**Критерии оценки сопряжения**

* **Объем связи**
    * число соединений между модулями (чем их меньше, тем лучше).
    * метод, принимающий 1 параметр лучше метода, принимающий 6 параметров.
    * класс с 4 открытыми методами, лучше, чем класс с 37 открытыми методами.

* **Видимость** - заметность связи между двумя модулями (стремиться к более заметной связи).

* **Гибкость** - чем проще вызывать модуль из других модулей, тем слабее он сопряжен.

**Виды сопряжения**

В порядке убывания рекомендаций (последнего и вовсе надо избегать):

1. **Простое сопряжение посредством данных параметров**
    Передаются только элементарные типы данных, причем передаются через списки параметров.

2. **Простое сопряжение посредством объекта**
    Модуль сопряжен с объектом этим способом, если он создает экземпляр данного объекта.

3. **Сопряжение посредством объекта-параметра**
    Объект 1 требует, чтобы Объект 2 передал ему Объект 3. 1 и 2 знают об объекте 3.

4. **Семантическое сопряжение** (плохо!)
    * (?) Модуль 1 передает в Модуль 2 управляющий флаг, определяющий дальнейшую работу Модуля 2.
    * Модуль 2 использует глобальные данные после их изменения Модулем 1.
    * Модуль 1 знает и зависит от порядка вызовов методов Модуля 2.
    * Модуль 1 передает не полностью инициализированный Объект в Модуль 2.
    * Модуль 1 передает в Модуль 2 Базовый Объект. Модуль 2 преобразует тип к производному объекту.

#### Старайтесь использовать популярные шаблоны проектирования

* Шаблоны снижают сложность, предоставляя готовые абстракции
(знакомая структура кода для знающих)

* Шаблоны снижают число ошибок, стандартизируя детали популярных решений
(не надо изобретать велосипед).

* Шаблоны имеют эвристическую ценность, указывая на возможные варианты проектирования
(можно легко перебрать список шаблонов и выбрать наиболее подходящий).

* Шаблоны упрощают взаимодействие между разработчиками, позволяя им общаться на более высоком уровне
(понятно для всех коллег без подробностей и деталей).

**Популярные паттерны**:
* Абстрактная фабрика (Abstract Factory)
    Поддерживает создание наборов родственных объектов путем определения вида набора,
    но не вида каждого отдельного объекта.

* Адаптер (Adapter)
    Преобразует интерфейс класса в другой интерфейс.

* Мост (Bridge)
    Создает интерфейс и реализацию, так что их можно изменять независимо друг от друга.

* Компоновщик (Composite)
    Состоит из объекта, содержащего дополнительные объекты такого же типа, позволяя клиентскому
    коду взаимодействовать с объектом верхнего уровня и не заботиться о детальных объектах.

* Декоратор (Decorator)
    Динамически назначает объекту виды ответственности без создания отдельных подклассов для
    каждой возможной конфигурации видов ответственности.

* Фасад (Facade)
    Предоставляет согласованный интерфейс к коду, который в противном случае не предоставлял бы
    согласованного интерфейса.

* Фабричный метод (Factory Method)
    Создает экземпляры классов, производных от конкретного базового класса, причем отдельные
    производные классы отслеживаются только «Фабричным методом».

* Итератор (Iterator)
    Этот серверный объект предоставляет доступ к каждому элементу набора в последовательном порядке.

* Наблюдатель (Observer)
    Поддерживает синхронизацию нескольких объектов, при которой объект уведомляет набор связанных
    объектов об изменениях любого члена набора.

* Одиночка (Singleton)
    Предоставляет глобальный доступ к классу, который может иметь один и только один экземпляр.

* Стратегия (Strategy)
    Определяет набор динамически взаимозаменяемых алгоритмов или видов поведения.

* Шаблонный метод (Template Method)
    Определяет структуру алгоритма, оставляя некоторые детали реализации подклассам.

#### Другие эвристические принципы

* **Стремитесь к максимальной связности**
    Связность (cohesion) характеризует то, насколько хорошо все методы класса или все фрагменты
    метода соответствуют главной цели, - иначе говоря, насколько сфокусирован класс.

* **Формируйте иерархии**
    Иерархия не устраняет детали — она просто выталкивает их на другой уровень,
    чтобы вы могли думать о них, когда захотите, а не все время.

* **Формализуйте контракты классов**
    Контракты помогают управлять сложностью, потому что хотя бы теоретически объект может свободно
    игнорировать любое поведение, не описанное в контракте.

* **Грамотно назначайте сферы ответственности**
    Обдумывание сфер ответственности, которые следует назначить объектам.

* **Проектируйте систему для тестирования**
    Проектирование системы под тесты заставляет минимизировать зависимость системы от других систем.

* (?) **Избегайте неудач**
    Больше рассматривать возможные причины сбоев и багов.

* **Тщательно выбирайте время связывания** (binding time)
    Это время, когда переменной присваивается конкретное значение. Раннее связывание обычно упрощает
    код, но и снижает его гибкость.

* **Создайте центральные точки управления**
    если какой-то программный элемент встречается в минимальном числе фрагментов, его изменение
    окажется проще и безопаснее.

* **Подумайте об использовании грубой силы**
    Работоспособное решение проблемы методом грубой силы лучше, чем элегантное, но не работающее
    решение.

* **Рисуйте диаграммы**

* **Поддерживайте модульность проекта системы**
    Каждый метод или класс должен быть похож на «черный ящик»: вы знаете, что в него поступает и
    что из него выходит, но не знаете, что происходит внутри.

#### Советы по использованию эвристических принципов

