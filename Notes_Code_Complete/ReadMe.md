# Часть II. Высококачественный код

## Глава 5. Проектирование при конструировании

### 5.1. Проблемы, связанные с проектированием ПО

**Проектирование ПО** - разработка или изобретение схемы преобразования спецификации приложения
в готовое приложение.

Проектирование — процесс, который связывает выработку требований с кодированием и отладкой.

С проектированием связано множество проблем — их-то мы и обсудим.

#### Проектирование — «грязная» проблема

"Грязная" проблема - это проблема, которую можно ясно определить только путем полного или
частичного решения.

По сути данный парадокс подразумевает, что проблему нужно «решить» один раз, чтобы получить ее
ясное определение, а затем еще раз для создания работоспособного решения.

Очень часто бывает, что только решив проблему можно обнаружить дополнительный аспект проблемы.

#### Проектирование - неряшливый процесс (даже если оно приводит к аккуратному результату)

Проектирование неряшливо потому что:
* Вы выполняете много неверных действий и попадаете во множество тупиков, т. е. совершаете массу
ошибок. Ошибки являются сутью проектирования: дешевле допустить ошибки и исправить проект программы,
чем найти их после кодирования и исправлять готовый код.

* Удачное решение часто лишь чуть-чуть отличается от неудачного.

* Трудно узнать, когда проект «достаточно хорош». (Чаще всего отвечают: «Когда у вас вышло время»).

#### Проектирование связано с определением компромиссов и приоритетов

Анализ конкурирующих характеристик проекта и достижение баланса между ними (быстродействие,
занимаемый объем, скорость разработки, ...).

#### Проектирование подразумевает ограничение возможностей

Ограниченные объемы ресурсов при проектировании ПО зданий требуют упрощения решения, что в итоге
приводит к его улучшению.

#### Проектирование — недетерминированный процесс

Спроектировать компьютерную программу можно десятками разных способов.

#### Проектирование — эвристический процесс

* Методы проектирования являются эвристическими методами, т. е. «практическими правилами» или
«способами, которые могут сработать», а не воспроизводимыми процессами.

* Проектирование — метод проб и ошибок.

* Инструменты или методы проектирования, оказавшиеся эффективными в одном случае, в другой ситуации
могут оказаться куда менее эффективными.

* Универсальных методик проектирования не существует.

#### Проектирование — постепенный процесс

Проекты приложений не возникают сразу в готовом виде. Они развиваются и улучшаются в ходе обзоров,
неформальных обсуждений, написания кода и выполнения его ревизий.
Практически во всех случаях проект несколько меняется во время первоначальной разработки системы и
еще больше — при ее модернизации.

### 5.2. Основные концепции проектирования

#### Главный Технический Императив Разработки ПО: управление сложностью

##### Существенные и несущественные проблемы

Cложность разработки ПО объясняется **существенными** и **несущественными** проблемами.

**Cущественными** называют свойства, которыми объект должен обладать, чтобы быть именно этим
объектом.

**Несущественными** (второстепенными, произвольными, необязательными и случайными) свойствами
называют свойства, которыми объект обладает в силу случайности, — свойства, не влияющие на его суть.

Многие несущественные проблемы разработки ПО уже давно решены: синтаксис языков программирования,
среды разработки, многозадачные ОС, ...

Решение оставшихся существенных проблем разработки ПО все более медленное: разработчики ПО берутся
за решение все более серьезных проблем реального мира, им приходится анализировать все
более сложные взаимодействия между сущностями.

##### Важность управления сложностью

Управление сложностью — самый важный технический аспект разработки ПО.

Ни один человек не обладает интеллектом, способным вместить все детали современного ПО. Надо
организовать программы так, чтобы можно было безопасно работать с их отдельными фрагментами по
очереди. Целью этого является минимизация объема программы, о котором нужно думать в конкретный
момент времени.

На уровне архитектуры ПО сложность проблемы можно снизить разделив систему на подсистемы.

В разбиении сложной проблемы на простые фрагменты и заключается цель всех методик проектирования ПО.

##### Как бороться со сложностью?

Чаще всего причинами неэффективности являются:
* сложное решение простой проблемы;
* простое, но неверное решение сложной проблемы;
* неадекватное сложное решение сложной проблемы;

Двойственный подход к управлению сложностью:

* старайтесь свести к минимуму объем существенной сложности, с которым придется работать в каждый
конкретный момент времени;

* сдерживайте необязательный рост несущественной сложности;

#### Желательные характеристики проекта

**Минимальная сложность**

* Избегайте создания «хитроумных» проектов.

* Если при работе над отдельным фрагментом программы проект не позволяет безопасно игнорировать
большинство остальных фрагментов, он неудачен.

**Простота сопровождения**

Проектируя приложение, не забывайте о программистах, которые будут его сопровождать.

**Слабое сопряжение (loose coupling)**

Слабое сопряжение (loose coupling) сводит к минимуму числа соединений между разными частями
программы. Для проектирования классов с минимальным числом взаимосвязей используйте принципы
адекватной абстракции интерфейсов, инкапсуляцию и сокрытие информации.

Это позволит максимально облегчить интеграцию, тестирование и сопровождение программы.

**Расширяемость**

Расширяемость системы позволяет улучшать систему, не нарушая ее основной структуры.
Изменение одного фрагмента системы не должно влиять на ее другие фрагменты.

**Возможность повторного использования**

Проектируйте систему так, чтобы ее фрагменты можно было повторно использовать в других системах.

**Высокий коэффициент объединения по входу (fan-in)**

К конкретному классу обращается большое число других классов.
Это значит, что система предусматривает интенсивное использование вспомогательных низкоуровневых классов.

**Низкий или средний коэффициент разветвления по выходу (fan-out)**

Конкретный класс обращается к малому или среднему числу других классов.
Высокий fan-out **более семи** говорит о том, что класс использует большое число других классов и,
возможно, слишком сложен.

**Портируемость**

Проектируйте систему так, чтобы ее можно было легко адаптировать к другой среде.

**Минимальная, но полная функциональность**

Отсутствие в системе лишних частей.

**Стратификация**

Разделение уровней декомпозиции, позволяющее изучить систему на любом отдельном уровне и
получить при этом согласованное представление. Проектируйте систему так, чтобы ее можно
было изучать на отдельных уровнях, игнорируя другие уровни.

Пример: система, которая должна использовать большой объем старого, плохо спроектированного кода.
Можно написать уровень, отвечающий за взаимодействие со старым кодом, который будет предоставлять
более новым уровням согласованный набор сервисов.

Пусть остальные части системы работают с этими классами вместо старого кода. Преимущества:
1) изоляция плохого кода и 2) при выбраывании старого кода или его рефакторинге, не придется
изменять новый код за исключением промежуточного уровня.

**Соответствие стандартным методикам**

Применять стандартные популярные подходы.

#### Уровни проектирования

1. Система
2. Разделение системы на подсистемы/пакеты
3. Разделение пакетов на классы
4. Разделение классов на данные и методы
5. Проектирование методов

**Уровень 1: программная система**

**Уровень 2: разделение системы на подсистемы или пакеты**

*При работе над совсем небольшим проектом этот уровень проектирования можно пропустить.*

Главный результат проектирования на этом уровне — определение основных подсистем.

Подсистемы могут быть довольно крупными: модуль работы с БД, модули GUI,
бизнес-правил или создания отчетов, интерпретатор команд и т. д.

Суть проектирования на данном уровне заключается в разделении программы на основные подсистемы и
определении взаимодействий между подсистемами.

Важный аспект этого уровня — определение правил взаимодействия подсистем.

Примеры решаемых вопросов:

* в скольких разных частях системы нужно хоть немного разбираться разработчику, желающему изменить
какой-то аспект подсистемы графических операций?

* что будет, если вы попытаетесь задействовать данный модуль бизнес-правил в другой системе?

* что будет, если вы захотите включить в систему новый пользовательский интерфейс?

* что произойдет, если вы захотите перенести модуль хранения данных на удаленный компьютер?

Архитектура системы должна быть такой, чтобы замена подсистем требовала как можно меньше возни
со связями между ними (приводится аналогия со шлангами).

* Организация коммуникации между подсистемами на основе принципа «необходимого знания».

* Стремиться к простоте отношений между подсистемами:
  * (Самая простая) Одна подсистема вызывает методы другой.
  * (Сложнее) Одна подсистема содержит классы другой.
  * (Самая сложная) Наследование классов одной подсистемы от классов другой

* Программа не должна содержать циклических отношений (A -> B -> C -> A).

Пример часто используемых подсистем:

1. *Подсистема бизнес-правил* - законы, директивы, политики и процедуры, реализуемые в компьютерной
системе.

2. *Подсистема пользовательского интерфейса*.

3. *Подсистема доступа к БД*.

4. *Подсистема изоляции зависимостей от ОС*. (Облегечение возможного портирования на другую ОС).

**Уровень 3: разделение подсистем на классы**

Этот уровень проектирования предполагает определение всех классов системы.

Сутью проектирования на данном уровне является декомпозиция подсистем до такого уровня детальности,
который позволит реализовать части подсистем в форме отдельных классов.

На этом уровне следует определить детали взаимодействия каждого класса с остальными элементами
системы, особенно интерфейс класса.

Например, подсистема доступа к БД может быть далее разделена на классы доступа к данным и
классы хранения данных, а также метаданные БД.

**Уровень 4: разделение классов на методы**

*Часто выполняется отдельными программистами*

Данный уровень проектирования заключается в разделении каждого класса на
методы.

Некоторые методы уже будут определены на уровне 3, при проектировании интерфейсов классов.

На уровне 4 вы детально определите закрытые методы классов. Полное определение методов класса часто
позволяет лучше понять его интерфейс, что может подтолкнуть к соответствующему изменению интерфейса,
т. е. к возвращению на уровень 3.

**Уровень 5: проектирование методов**

*Обычно выполняется отдельными программистами*

### 5.3. Компоненты проектирования: эвристические принципы

*Набор рекомендаций, т.к. процесс проектирования недетерминирован.*

#### Определите объекты реального мира

Самый популярный, подход к проектированию основан на определении объектов реального мира и
искусственных объектов.

Определяются:
* объекты и их атрибуты (методы и данные);
* действия, которые могут быть выполнены над каждым объектом;
* действия, которые каждый объект может выполнять над другими объектами;
* части каждого объекта, видимые другим объектам, т. е. открытые и закрытые части;
* открытый интерфейс каждого объекта;

**Определите объекты и их атрибуты**

Каждый объект имеет характеристики, релевантные для компьютерной программы.

**Определите действия, которые могут быть выполнены над каждым объектом**

Объекты могут поддерживать самые разные операции.

**Определите действия, которые каждый объект может выполнять над другими объектами**

Двумя универсальными действиями, которые объекты могут выполнять друг над другом, являются
**включение** (containment) и **наследование**.

**Определите части каждого объекта, видимые другим объектам**

Определение частей объекта, которые следует сделать открытыми, и частей, которые следует держать
закрытыми (требуется для данных и методов).

**Определите интерфейс каждого объекта**

* *Открытый интерфейс* - данные и методы, которые объект предоставляет в распоряжение
остальным объектам.

* *Защищенный интерфейс* - части объекта, доступные только производным от него объектам.

#### Определите согласованные абстракции

Абстракция позволяет задействовать концепцию, игнорируя ее некоторые детали и работая с разными
деталями на разных уровнях.

Удачный интерфейс класса — это абстракция, позволяющая сосредоточиться на интерфейсе,
не беспокоясь о внутренних механизмах работы класса.

Абстракции на уровне интерфейсов методов, интерфейсов классов и интерфейсов пакетов.

#### Инкапсулируйте детали реализации

Инкапсуляция помогает управлять сложностью, блокируя доступ к ней. (Скрытие тонкостей реализации).

#### Используйте наследование, если оно упрощает проектирование

Очень часто одни объекты аналогичны другим за исключением нескольких различий.
Определение сходств и различий между такими объектами называется «наследованием».

#### Скрывайте секреты (к вопросу о сокрытии информации)

Сокрытие информации оказывается особенно мощным эвристическим принципом, так как все его
аспекты и даже само название подчеркивают сокрытие сложности.

Один из важнейших аспектов проектирования класса — принятие решения о том, какие свойства сделать
доступными вне класса, а какие оставить секретными.

Класс может использовать несколько типов данных, не раскрывая сведений о них.

Интерфейс класса должен сообщать как можно меньше о внутренней работе класса.

**Две категории секретов**

* секреты, которые скрывают сложность, позволяя программистам забыть о ней при работе над
остальными частями программы. (сложные типы данных, файловые структуры, булевы тесты,
запутанные алгоритмы, ...)

* секреты, которые скрывают источники изменений с целью локализации результатов возможных изменений.

**Барьеры, препятствующие сокрытию информации**

* **Избыточное распространение информации**

    Примеры:
    * магическое число, которое используется в нескольких местах программы.
    * распределение взаимодействия с пользователями по разным местам в программе.
    * глобальный "необернутый" элемент данных (например, массив).

* **Круговая зависимость**

    Метод класса A вызывает метод класса B, а метод B вызывает метод класса A.

* **Ошибочное представление о данных класса как о глобальных данных**

    Недостатки глобальных данных:
    * методы, обращающиеся к глобальным данным, не знают о том, что другие методы тоже
    обращаются к этим данным.
    * методы не знают, что именно другие методы делают с глобальными данными.

* **Кажущееся снижение производительности**

**Важность сокрытия информации**

Размышление о том, что скрыть, способствует принятию удачных решений на всех уровнях проектирования.

#### Определите области вероятных изменений

1. Определите элементы, изменение которых кажется вероятным.
2. Отделите элементы, изменение которых кажется вероятным.
3. Изолируйте элементы, изменение которых кажется вероятным.

Несколько областей, которые меняются чаще всего (что лучше изолировать):
* Бизнес правила
* Зависимости от оборудования
* Ввод-вывод (формат файлов, формат и вид данных, ...)
* Нестандартные возможности языка
* Сложные аспекты проектирования и конструирования
* Переменные статуса
    * В качестве переменных статуса примениять перечисления.
    * Вместо непосредственной проверки переменной используйте методы доступа.
* Размеры структур данных (например, длину массива задать с помощью именованной константы).

**Предвосхищение изменений разного масштаба**

Совет. Примерная последовательность шагов для определения мест с вероятными изменениями:
1. Определить минимальное подмножество фрагментов программы, необходимых пользователям (**ядро системы**).
2. Мнимальные инкрементные приращения системы.
    * Функциональные изменения
    * Качественные изменения (обеспечение безопасности в многопоточной среде,
    поддержка механизмов локализации, ...)

Минимальные приращения вероятнее всего будут наиболее часто изменяемы.

#### Поддерживайте сопряжение слабым (loose coupling)

* Цель — создать классы и методы, имеющие немногочисленные, непосредственные, явные и
гибкие отношения с другими классами.

* Сопряжение модулей должно быть достаточно слабым, чтобы одни модули могли с легкостью
использовать другие.

* Старайтесь создавать модули, слабо зависящие от других модулей.

**Критерии оценки сопряжения**

* **Объем связи**
    * число соединений между модулями (чем их меньше, тем лучше).
    * метод, принимающий 1 параметр лучше метода, принимающий 6 параметров.
    * класс с 4 открытыми методами, лучше, чем класс с 37 открытыми методами.

* **Видимость** - заметность связи между двумя модулями (стремиться к более заметной связи).

* **Гибкость** - чем проще вызывать модуль из других модулей, тем слабее он сопряжен.

**Виды сопряжения**

В порядке убывания рекомендаций (последнего и вовсе надо избегать):

1. **Простое сопряжение посредством данных параметров**
    Передаются только элементарные типы данных, причем передаются через списки параметров.

2. **Простое сопряжение посредством объекта**
    Модуль сопряжен с объектом этим способом, если он создает экземпляр данного объекта.

3. **Сопряжение посредством объекта-параметра**
    Объект 1 требует, чтобы Объект 2 передал ему Объект 3. 1 и 2 знают об объекте 3.

4. **Семантическое сопряжение** (плохо!)
    * (?) Модуль 1 передает в Модуль 2 управляющий флаг, определяющий дальнейшую работу Модуля 2.
    * Модуль 2 использует глобальные данные после их изменения Модулем 1.
    * Модуль 1 знает и зависит от порядка вызовов методов Модуля 2.
    * Модуль 1 передает не полностью инициализированный Объект в Модуль 2.
    * Модуль 1 передает в Модуль 2 Базовый Объект. Модуль 2 преобразует тип к производному объекту.

#### Старайтесь использовать популярные шаблоны проектирования

* Шаблоны снижают сложность, предоставляя готовые абстракции
(знакомая структура кода для знающих)

* Шаблоны снижают число ошибок, стандартизируя детали популярных решений
(не надо изобретать велосипед).

* Шаблоны имеют эвристическую ценность, указывая на возможные варианты проектирования
(можно легко перебрать список шаблонов и выбрать наиболее подходящий).

* Шаблоны упрощают взаимодействие между разработчиками, позволяя им общаться на более высоком уровне
(понятно для всех коллег без подробностей и деталей).

**Популярные паттерны**:
* Абстрактная фабрика (Abstract Factory)

    Поддерживает создание наборов родственных объектов путем определения вида набора,
    но не вида каждого отдельного объекта.

* Адаптер (Adapter)

    Преобразует интерфейс класса в другой интерфейс.

* Мост (Bridge)

    Создает интерфейс и реализацию, так что их можно изменять независимо друг от друга.

* Компоновщик (Composite)

    Состоит из объекта, содержащего дополнительные объекты такого же типа, позволяя клиентскому
    коду взаимодействовать с объектом верхнего уровня и не заботиться о детальных объектах.

* Декоратор (Decorator)

    Динамически назначает объекту виды ответственности без создания отдельных подклассов для
    каждой возможной конфигурации видов ответственности.

* Фасад (Facade)

    Предоставляет согласованный интерфейс к коду, который в противном случае не предоставлял бы
    согласованного интерфейса.

* Фабричный метод (Factory Method)

    Создает экземпляры классов, производных от конкретного базового класса, причем отдельные
    производные классы отслеживаются только «Фабричным методом».

* Итератор (Iterator)

    Этот серверный объект предоставляет доступ к каждому элементу набора в последовательном порядке.

* Наблюдатель (Observer)

    Поддерживает синхронизацию нескольких объектов, при которой объект уведомляет набор связанных
    объектов об изменениях любого члена набора.

* Одиночка (Singleton)

    Предоставляет глобальный доступ к классу, который может иметь один и только один экземпляр.

* Стратегия (Strategy)

    Определяет набор динамически взаимозаменяемых алгоритмов или видов поведения.

* Шаблонный метод (Template Method)

    Определяет структуру алгоритма, оставляя некоторые детали реализации подклассам.

#### Другие эвристические принципы

* **Стремитесь к максимальной связности**

    Связность (cohesion) характеризует то, насколько хорошо все методы класса или все фрагменты
    метода соответствуют главной цели, - иначе говоря, насколько сфокусирован класс.

* **Формируйте иерархии**

    Иерархия не устраняет детали — она просто выталкивает их на другой уровень,
    чтобы вы могли думать о них, когда захотите, а не все время.

* **Формализуйте контракты классов**

    Контракты помогают управлять сложностью, потому что хотя бы теоретически объект может свободно
    игнорировать любое поведение, не описанное в контракте.

* **Грамотно назначайте сферы ответственности**

    Обдумывание сфер ответственности, которые следует назначить объектам.

* **Проектируйте систему для тестирования**

    Проектирование системы под тесты заставляет минимизировать зависимость системы от других систем.

* (?) **Избегайте неудач**

    Больше рассматривать возможные причины сбоев и багов.

* **Тщательно выбирайте время связывания** (binding time)

    Это время, когда переменной присваивается конкретное значение. Раннее связывание обычно упрощает
    код, но и снижает его гибкость.

* **Создайте центральные точки управления**

    Если какой-то программный элемент встречается в минимальном числе фрагментов, его изменение
    окажется проще и безопаснее.

* **Подумайте об использовании грубой силы**

    Работоспособное решение проблемы методом грубой силы лучше, чем элегантное, но не работающее
    решение.

* **Рисуйте диаграммы**

* **Поддерживайте модульность проекта системы**

    Каждый метод или класс должен быть похож на «черный ящик»: вы знаете, что в него поступает и
    что из него выходит, но не знаете, что происходит внутри.

#### Советы по использованию эвристических принципов

1. **Понимание постановки задачи**
    * Что неизвестно?
    * Что дано?
    * В чем состоит условие?
    * Возможно ли удовлетворить условию?
    * Достаточно ли условие для определения неизвестного? Или недостаточно?
    * Сделайте чертеж.
    * Введите подходящие обозначения.
    * Разделите условие на части.
    * Постарайтесь их записать.

2. **Составление плана решения**
    * Цель - прийти к плану решения.
    * Найти связь между данными и неизвестными.
    * Известна ли родственная задача?
    * Есть ли задача с тем же или подобным неизвестным?
    * Нельзя ли иначе сформулировать задачу?
    * Нельзя ли придумать более доступную задачу?
    * Нельзя ли решить часть задачи?
    * Все ли данные использованы?

3. **Осуществление плана**
    * Нужно осуществить план решения.
    * Осуществляя план решения, контролируйте каждый свой шаг.

4. **Взгляд назад**
    * Нужно изучить найденное решение.
    * Проверить ход решения?
    * Можно ли получить тот же результат иначе?
    * Где еще можно использовать полученный результат?

Одним из самых ценных советов, которые можно дать по поводу проектирования
ПО,является использование разных подходов.

### 5.4. Методики проектирования

#### Используйте итерацию

* Проектирование — итеративный процесс.

* При каждой попытке вы будете узнавать что-то такое, что поможет вам
улучшить общий проект.

* Общая картина, которую вы получаете при работе над высокоуровневыми
вопросами, поможет вам лучше понять низкоуровневые детали.

* Детали, которые вы узнаете при работе над низкоуровневыми вопросами,
помогут вам создать прочный фундамент для принятия высокоуровневых решений.

#### Разделяй и властвуй

Разделите программу на разные области и спроектируйте их по отдельности.

#### Нисходящий и восходящий подходы к проектированию

* Нисходящее (top-down) проектирование
    * начинается на высоком уровне абстракции.
    * сначала определяются базовые классы или другие неспецифические элементы проекта.
    * повышается уровень детальности и определяются производные классы, сотрудничающие
    классы и другие детали.

* Восходящее (bottom-up) проектирование
    * начинается со специфики и постепенно переходит ко все большей общности.
    * начинается с определения конкретных объектов.
    * затем разрабатываются более общие объединения объектов и базовые классы.

**Аргументы в пользу нисходящего проектирования**

* Мозгу не приходится иметь дело со слишком большим числом деталей сразу.
* Итеративный процесс «разделяй и властвуй».
* Обычно не ограничиваются одной попыткой декомпозиции, что приводит к улучшению проекта.
* Декомпозицию можно продолжать до полной простоты отдельных частей проекта.
* Легче восходящего.
* Позволяет отложить работу над деталями конструирования.

**Аргументы в пользу восходящего проектирования**

* Определить какие функции должна выполнять система.
* Определить низкоуровневые ответственности и назначить их конкретным классам.
* Определить общие объекты, сгруппировать и организовать их в подсистемы или пакеты,
с помощью композиции или наследования.
* Подняться на следующий уровень или вернуться на вершину. Попробовать еще раз начать
нисходящее проектирование.
* Раннее определение вспомогательной функциональности.

#### Экспериментальное прототипирование

Иногда вы не можете полностью определить проблему проектирования, пока не решите ее хоть
частично. Решение - экспериментальное прототипирование.

* Написание абсолютно минимального объема кода.
* Задача должна быть достаточно конкретна.
* Код прототипа должен быть выброшен. Решения:
    * Создание прототипа на другом языке.
    * Использовать префиксы.

#### Совместное проектирование

* Обсуждение с коллегой идей.
* Парное программирование.
* Собрание для обсуждения своих идей с одним или несколькими коллегами.
* Формальная инспекция. (Наиболее качественный код).
* Возвращение к своей работе через некоторое время.
* Обращение за помощью к людям, не работающим в вашей компании (форумы и т.п.).

#### Какую степень проектирования считать достаточной?

При создании конкретной системы могут иметь место сразу несколько факторов подталкивающих
к разным решениям.

Если разработчики выполняют какую#то часть проектирования индивидуально, то при снижении
проектирования до уровня задачи, которая уже была решена ранее, или до уровня простого
изменения или расширения такой задачи, проектирование, вероятно, можно прекратить и
начать кодирование.

Если я не могу решить, насколько детальным должен быть проект программы перед началом
кодирования, я предпочитаю разрабатывать его более детально.

Но и нельзя делать проекты, страдающие от слишком объемной проектной документации.

#### Регистрация процесса проектирования

**Включайте проектную документацию прямо в код**

Документируйте основные аспекты проектирования в комментариях — как правило, в
заголовках файлов или классов.

**Регистрируйте протоколы обсуждения проекта и принятые решения при помощи Wiki**

**Пишите резюме дискуссий в форме электронной почты**

**Используйте цифровой фотоаппарат**

Фотографируйте диаграммы, которые разработчики рисуют на доске, и включайте их в
традиционные документы.

**Храните плакаты со схемами проекта**

Хранить их в удобном месте или, что еще лучше, развесить на стенах.

**Используйте карточки CRC**

(Class, Responsibility, Collaborator — класс, ответственность, сотрудничество)

Еще один простой вариант документирования проекта — использовать карточки.

Напишите на каждой карточке имя класса, аспекты его ответственности и имена классов,
с которыми он сотрудничает. Продолжайте работать с карточками, пока не будете
удовлетворены результатом.

**Создавайте диаграммы UML с уместным уровнем детальности**

UML - Unified Modeling Language -  унифицированный язык моделирования.

### 5.5. Комментарии по поводу популярных методологий

Какой объем проектирования достаточен? Никто не может точно ответить на этот вопрос.

Тем не менее можно с полной уверенностью утверждать, что проектирование всех деталей
до единой и полное отсутствие проектирования - это ошибочные точки зрения.

* Рассматривайте проектирование как грязный, неряшливый эвристический процесс.
* Не останавливайтесь на первом проекте, который пришел вам в голову.
* Сотрудничайте.
* Стремитесь к простоте.
* Создавайте прототипы, если нужно.
* Не забывайте про итерацию.

### Контрольный список: проектирование при конструировании

#### Методики проектирования

* Выполнили ли вы несколько итераций проектирования, выбрав самую лучшую попытку, а
  не просто первую?

* Попробовали ли вы выполнить декомпозицию системы несколькими способами с целью
  нахождения наилучшего варианта?

* Использовали ли вы для решения проблемы и нисходящий, и восходящий способы
  проектирования?

* Выполнили ли вы прототипирование сомнительных или плохо известных частей системы,
  создав абсолютный минимум подлежащего выбрасыванию кода, нужного для ответа на
  отдельные вопросы?

* Был ли выполнен формальный или неформальный обзор вашего проекта другими
  разработчиками?

* Довели ли вы проектирование до той точки, в которой реализация проекта кажется
  очевидной?

* Выполнили ли вы регистрацию проекта уместными способами, такими как Wiki,
  электронная почта, плакаты, цифровые фотографии, UML, карточки CRC или комментарии
  в самом коде?

#### Цели проектирования

* Адекватно ли проект решает проблемы, которые были определены и отложены на этапе
  разработки архитектуры?

* Разделен ли проект на уровни?

* Удовлетворены ли вы тем, как выполнена декомпозиция программы на подсистемы, пакеты
  и классы?

* Удовлетворены ли вы тем, как выполнена декомпозиция классов на методы?

* Достигнуто ли минимальное взаимодействие классов между собой?

* Спроектированы ли классы и подсистемы так, чтобы их можно было использовать в
  других системах?

* Будет ли программа легкой в сопровождении?

* Является ли проект полным, но минимальным? Все ли его части действительно
  необходимы?

* Подразумевает ли проект использование только стандартных методик?
  Смогли ли вы избежать применения экзотических, трудных для понимания элементов?

* Помогает ли проект в целом минимизировать и несущественную, и существенную
  сложность?

### Ключевые моменты

1. Главным Техническим Императивом Разработки ПО является управление сложностью.
   Управлять сложностью будет гораздо легче, если при проектировании вы будете
   стремиться к простоте.

2. Есть два общих способа достижения простоты: минимизация объема существенной
   сложности, с которой приходится иметь дело в любой конкретный момент
   времени, и подавление необязательного роста несущественной сложности.

3. Проектирование — эвристический процесс. Слепое следование какой-либо
   единственной методологии подавляет творческое мышление и снижает качество ваших
   программ.

4. Оптимальный процесс проектирования итеративен; чем больше вариантов проектирования
   вы попробуете, тем удачнее будет ваш окончательный проект.

5. Одной из самых полезных концепций проектирования является сокрытие информации.
   Вопрос «Что мне скрыть?» устраняет много сложных проблем проектирования.

## Глава 6. Классы

**Класс** — это набор данных и методов, имеющих общую, целостную, хорошо определенную
сферу ответственности.

*Данные* — необязательный компонент класса: класс может включать только методы, предоставляющие целостный набор услуг.

Одним из главных условий эффективного программирования является максимизация части программы, которую можно игнорировать при работе над конкретными фрагментами кода. Классы — главное средство достижения этой цели.

### 6.1. Основы классов: абстрактные типы данных (АТД)

**АТД** — это набор, включающий данные и выполняемые над ними операции. Операции
описывают данные для остальной части программы и позволяют их изменять.

Примеры АТД:

* графическое окно со всеми операциями
* файл с файловыми операциями
* таблица страховых тарифов с соответствующими операциями
* ...

#### Преимущества использования АТД

* *Возможность сокрытия деталей реализации*

* *Ограничение области изменений*

  При необходимости изменения типа данных вы сможете изменить его в одном месте, не
  влияя на всю программу.

* *Более высокая информативность интерфейса*

* *Легкость оптимизации кода*

* *Легкость проверки кода*

* *Удобочитаемость и понятность кода*

* *Ограничение области использования данных*

* *Возможность работы с сущностями реального мира, а не с низкоуровневыми деталями
  реализации*

#### Принципы использования АТД

* Представляйте в форме АТД распространенные низкоуровневые типы данных

  Примеры: Стек, список, очередь.
  Примеры из реальности: набор сотрудников, ячейки электронной таблицы.

* Представляйте в форме АТД часто используемые объекты, такие как файлы.

  Аналогично, для проблем реального мира.

* Представляйте в форме АТД даже простые элементы

  Пример: простой фонарь, который можно включить и выключить.

* Обращайтесь к АТД так, чтобы это не зависело от среды, используемой для его хранения
  * Скрывать внутренности АТД.
  * Присваивать классам и методам доступа имена, не зависящим от способа хранения
    данных.
  * Обращаться не к конкретным сущностям, а к АТД.

#### Работа с несколькими экземплярами данных при использовании АТД в средах, не являющихся объектно-ориентированными

1. Надо создать для АТД сервисы создания и уничтожения экземпляров данных.
2. Спроектировать другие сервисы АТД так, чтобы они могли работать с несколькими экземплярами.

Три варианта реализации взаимодействия с АТД.

1. Явно указывать экземпляр данных при каждом обращении к сервисам АТД.
   В каждый метод, передавать id экземпляра данных.

2. Тип данных, который меняется, передается в каждый из сервисных методов АТД.

3. Использовать неявные экземпляры (с большой осторожностью). Создается сервис
   управления жкземплярами объектов, который устанавливает заданный экземпляр текущим.
   После этого все остальные сервисы используют текущий объект, благодаря чему в них не нужно передавать параметр id.

   В сложных системах (да и вообще в любых приложениях) данный 3 подход использовать
   не рекомендуется.

#### АТД и классы

Можно рассматривать класс как АТД, поддерживающий наследование и полиморфизм.

### 6.2. Качественные интерфейсы классов. Признаки

#### Хорошая абстракция

Под **абстракцией** понимается представление сложной операции в упрощенной
форме.

**Интерфейс класса** — это абстракция реализации класса, скрытой за интерфейсом.
Интерфейс класса должен предоставлять группу методов, четко согласующихся друг с
другом.

Для высококачественных абстрактных интерфейсов в классах, соблюдать следующие принципы:

**Интерфейс класса должен представлять согласованный уровень абстракции**

В идеале каждый класс должен быть реализацией только одного АТД. Если класс реализует более одного АТД или не удается определить реализацией какого АТД он является, то этот класс надо реорганизовать в один или несколько АТД.

**Понять реализацией какой абстракции является класс**

Пример: таблица. В ее основе могут быть элементы такие как сетка и электронная таблица. Надо четко понять, что будет доступно "снаружи", а что нет.

**Предоставляйте методы вместе с противоположными им методами**

При проектировании класса проверьте каждый открытый метод на предмет того, требуется
ли вам его противоположность.

**Убирайте постороннюю информацию в другие классы**

Если одни методы класса работают с одной половиной данных, а другие — с другой,
значит этот класс надо разделить на два класса.

**Стараться делать интерфейсы программными, а не семантическими**

Пример семантического интерфейса:

* "Метод А должен быть вызван перед Методом B"

* "Метод А вызовет ошибку, если переданные данные не будут предварительно
инициализированы".

Любой аспект интерфейса, который не может быть проверен компилятором, является потенциальным источником ошибок.

Старайтесь преобразовывать семантические элементы интерфейса в программные, используя утверждения (assertions) или иными способами.

**Опасайтесь нарушения целостности интерфейса при изменении класса**

Чистый класс после добавлений и правок может превратиться в смесь несогласованных
методов.

**Не включайте в класс открытые члены, плохо согласующиеся с абстракцией интерфейса**

Добавляя новый метод в интерфейс класса, всегда задавать вопрос о согласовании
метода с абстракцией, формируемого существующим интерфейсом.

**Рассматривайте абстракцию и связность вместе**

Интерфейс класса, представляющий хорошую абстракцию, обычно отличается высокой связностью. И наоборот: классы, имеющие высокую связность, обычно представляют хорошие абстракции.

#### Хорошая инкапсуляция

Абстракция и инкапсуляция связаны друг с другом, без первой не может быть второй и
наоборот.

Абстракция управляет сложностью и игнорирует детали реализации. Инкапсуляция не
позволяет узнать детали реализации.

**Минимизируйте доступность классов и их членов**

Если предоставление доступа к методу согласуется с абстракцией, сделайте
его открытым. Если вы не уверены, скрыть больше обычно предпочтительнее, чем
скрыть меньше.

**Не делайте данные-члены открытыми**

Предоставление доступа к данным-членам нарушает инкапсуляцию и ограничивает контроль
над абстракцией.

Пример: координаты точки.

**Не включайте в интерфейс класса закрытые детали реализации**

Пример: в заголовочном файле C++ видны закрытые детали реализации.

**Класс не должен что-либо требовать от клиентов**

**Избегайте использования дружественных классов**

Иногда дисциплинированное использование дружественных классов помогает управлять
сложностью. Пример: шаблон "Состояние" (State).

Однако, обычно дружественные классы нарушают инкапсуляцию.

**Не делайте метод открытым лишь потому, что он использует только открытые методы**

**Легкость чтения кода лучше, чем удобство его написания**

Пример: "удобный" метод, который хочется включить в интерфейс класса. Но метод
не согласуется с абстракцией класса. Метод лучше не включать в интефейс.

**Очень настороженно относитесь к семантическим нарушениям инкапсуляции**

Плохо:
* некоторые методы надо обязательно вызвать до вызова других.
* необходимость знаниния о способе хранения объекта, который для тебя предоставлен
  другим объектом.

**Остерегайтесь слишком жесткого сопряжения**

*Сопряжение* (coupling) характеризует силу связи между двумя классами. Чем сопряжение
слабее, тем лучше. Правила:

* минимизируйте доступность классов и их членов;
* избегайте дружественных классов, потому что они связаны жестко;
* делайте данные базового класса закрытыми, а не защищенными: это ослабляет
  сопряжение производных классов с базовым;
* не включайте данные-члены в открытый интерфейс класса;
* остерегайтесь семантических нарушений инкапсуляции;
* соблюдайте «Правило Деметры» (см. далее, раздел 6.3).

### 6.3. Вопросы проектирования и реализации

#### Включение (отношение «содержит»)

*Сущность включения* (containment): один класс содержит примитивный элемент данных
или другой класс.

**Реализуйте с помощью включения отношение «содержит»**

Например, объект «сотрудник» может «содержать» фамилию, номер телефона и т.д.

**В самом крайнем случае реализуйте отношение «содержит» при помощи закрытого наследования**

Обычно это указывает на ошибки проектирования.

**Настороженно относитесь к классам, содержащим более семи элементов данных-членов**

Ориентир 7 +- 2 дискретных элемента. (Столько объектов удерживается в памяти).

Максимум 9 примитивных типов данных-членов класса и максимум 5 - для сложных объектов.

#### Наследование (отношение «является»)

*Наследование* подразумевает, что один класс является более специализированным
вариантом другого класса.

Цель наследования — создать более простой код, что достигается путем определения
базового класса, идентифицирующего общие элементы двух или более производных
классов. Общими элементами могут быть интерфейсы методов, их реализация,
данные-члены или типы данных. Наследование помогает избегать повторения кода и
данных в нескольких местах, централизуя их в базовом классе.

Планируя использовать наследование, вы должны принять несколько решений:

* Будет ли конкретный метод-член доступен производным классам?
* Будет ли он иметь реализацию по умолчанию?
* Можно ли будет переопределить его реализацию по умолчанию?
* Будут ли конкретные данные-члены (в том числе переменные, именованные константы,
  перечисления и т. д.) доступны производным классам?

**Реализуйте при помощи открытого наследования отношение «является»**

Если производный класс не собирается полностью придерживаться контракта,
определенного интерфейсом базового класса, наследование выполнять не стоит.

**Проектируйте и документируйте классы с учетом возможности наследования или запретите его**

Если при проектировании класса вы решили, что он не должен поддерживать наследовани
не объявляйте его члены как *virtual* в случае C++ или если вы программируете на
Java, объявите члены такого класса как *final*.

**Соблюдайте принцип подстановки Лисков (Liskov Substitution Principle, LSP)**

Наследование стоит использовать, только если производный класс действительно
«является» более специализированной версией базового класса.

Пример: разная семантика одноименных методов у базового и производного классов.
(*От себя: классический пример прямоугольник->квадрат*).

**Наследуете только то, что хотите наследовать**

Наследуемые методы могут относиться к одной из трех категорий:

* абстрактный переопределяемый метод: производный класс наследует интерфейс метода,
  но не его реализацию;
* переопределяемый метод: производный класс наследует интерфейс метода и его
  реализацию по умолчанию, а также может переопределить эту реализацию;
* непереопределяемый метод: производный класс наследует интерфейс метода и его
  реализацию по умолчанию, переопределить которую не может.

Советы:

* Не наследуйте реализацию только потому, что вы наследуете интерфейс, и не
  наследуйте интерфейс только для того, чтобы унаследовать реализацию.
* Если вам нужна реализация класса, но не его интерфейс, используйте включение, а не
  наследование.

**Не используйте имена непереопределяемых методов базового класса в производных классах**

**Перемещайте общие интерфейсы, данные и формы поведения на как можно более высокий уровень иерархии наследования**

Какой уровень считать самым высоким? Руководствуйтесь соображениями абстракции. Если
перемещение метода выше нарушает абстракцию класса, то перемещений достаточно.

**С подозрением относитесь к классам, объекты которых создаются в единственном экземпляре** (? непонятное объяснение)

**С подозрением относитесь к базовым классам, имеющим только один производный класс**

Иерархию наследования не надо усложнять без крайней нужды.

**С подозрением относитесь к классам, которые переопределяют метод, оставляя его пустым**

* Класс-наследник нарушает абстракцию (контракт интерфейса) базового класса,
  изменяя семантику его интерфейса.
* При расширении на другие производные классы этот подход быстро становится
  неуправляемым.
* Код, написанный по этой методике, трудно сопровождать, потому что со временем
  поведение производных классов начинает сильно отличаться от интерфейсов и форм
  поведения базовых классов.

Решение: перепроектировние иерархии классов, использовние включения вместо наследования.

**Избегайте многоуровневых иерархий наследования**

Рекомендации:

* 2-3 уровня наследования.
* 7+-2 максимально допустимое общее количество подклассов базового класса.

**Предпочитайте полиморфизм, а не крупномасштабную проверку типов**

Наличие в коде большого числа блоков *case* может указывать на то, что программу лучше
было бы спроектировать, используя наследование, хотя это верно не всегда.

**Делайте все данные закрытыми, а не защищенными**

Выполняя наследование от класса, вы получаете привилегированный доступ к его
защищенным методам и данным. Если производному классу на самом деле нужен доступ к
атрибутам базового класса, включите в базовый класс *защищенные методы доступа*.

#### Множественное наследование

Единственно допустимый вид множественного наследования - создание «миксинов» — простых
классов, позволяющих добавить ряд свойств в другой класс. *Миксины* (от слова
mix in) называются так потому, что они позволяют подмешать  свойства в производные
классы.

По сути это возможность имплементации одним классов нескольких интерфейсов
(как в Java и C#).

#### Итог. Как использовать наследование и включение (рекомендации)

* Если классы имеют общие данные, но не формы поведения - создать общий объект,
  который можно было бы включить во все эти классы.

* Если классы имеют общие формы поведения, но не данные - сделать эти классы
  производными от общего базового класса, определяющего общие методы.

* Если классы имеют общие данные и формы поведения - сделать эти классы производными
  от общего базового класса, определяющего общие данные и методы.

* Использовать наследование, если надо, чтобы интерфейс определялся базовым классом.

* Использоватьи включение, если надо контролировать интерфейс.

#### Методы-члены и данные-члены. Советы по реализации.

Советы по эффективной реализации методов-членов и данных-членов.

* Включайте в класс как можно меньше методов

  Меньше ошибок, меньше сопряжений между классами.

* Блокируйте неявно сгенерированные методы и операторы, которые вам не нужны

  Блокировать, то, что необходимо для успешной компиляции.
  Пример блокировки: создание закрытого конструктора по умолчанию.

* Минимизируйте число разных методов, вызываемых классом

  Число дефектов в коде класса повышается при с общим числом методов, вызываемых классом и при увеличении числа используемых в нем классов.

* Избегайте опосредованных вызовов методов других классов (правило Деметры)

  Пример. Плохо вызывать цепочки вида `account.ContactPerson().DaytimeContactInfo()`.
  Но вызов `account.ContactPerson()` приемлем.

* Минимизируйте сотрудничество класса с другими классами

  * Минимизировать число видов создаваемых объектов
  * Минимизировать число непосредственно вызываемых методов созданных объектов
  * Минимизировать число вызовов методов, принадлежащих объектам, возвращенным другими
    созданными объектами.

#### Конструкторы. Советы по реализации.

* Инициализируйте по мере возможности все данные-члены во всех конструкторах.

* Создавайте классы-одиночки с помощью закрытого конструктора.

* Если сомневаетесь, выполняйте полное копирование, а не ограниченное

  * Полные копии легче в реализации и сопровождении, чем ограниченные.
  * Сомнительное улучшением быстродействия кода при ограниченном копировании.

### 6.4. Разумные причины создания классов

* Моделирование объектов реального мира

* Моделирование абстрактных объектов

  *Абстрактный объект* - объект, который не существует в реальном мире, но является
  абстракцией других конкретных объектов. Пример — классический объект `Shape` (фигура).

* Снижение сложности (самая важная причина создания класса)

  Создание класса для сокрытия информации, чтобы о ней можно было не думать.

* Изоляция сложности

  * При возникновении ошибки ее будет проще найти, если она будет локализована в классе.
  * Легче править и отлаживать.

* Сокрытие деталей реализации

* Ограничение влияния изменений

  Проектируйте приложение так, чтобы области вероятных изменений можно было изменить с
  максимальной легкостью. Примеры областей с вероятными изменениями: зависимости от
  оборудования, подсистема ввода/вывода, сложные типы данных и бизнес-правила.

* Сокрытие глобальных данных

  Обращение к глобальным данным через методы доступа позволяет:
  * Менять структуру данных не меняя программу.
  * Следить за доступом к данным.

* Упрощение передачи параметров в методы

  Методы класса могут использовать его данные вместо данных передаваемых через
  параметры метода.

* Создание центральных точек управления

  Примеры: управление файлами, соединениями с БД, принтерами, ...

* Облегчение повторного использования кода

  Код, разбитый на грамотно организованные классы, легче повторно использовать в других программах, чем тот же код, помещенный в один более крупный класс.

  Даже если фрагмент вызывается только из одного места программы и вполне понятен в
  составе более крупного класса, подумайте, может ли он понадобиться в другой
  программе. Если да, стоит поместить его в отдельный класс.

