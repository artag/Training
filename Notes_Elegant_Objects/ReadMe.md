# Элегантные объекты

## Глава 1. Рождение

### 1.1. Не используйте имена, заканчивающиеся на -er и -or. Не используйте Util или Utils тоже.

Плохие имена: Util, Utils, Manager, Controller, Helper, Handler, Writer, Reader, Converter, Validator,
Router, Dispatcher, Observer, Listener, Sorter, Encoder и Decoder.

**Хорошие** имена: Target, EncodedText, DecodedData, Content, SortedLines, ValidPage, Source и т. п.
Также хорошо (исключения): Computer или User.

*Пример 1* вариантов имен для Cash:
* Плохо: CashFormatter.
* **Хорошо**: USDCash, CashInUSD.

*Пример 2* список простых чисел:
* Плохо: Primer, PrimeFinder, PrimeChooser, PrimeHelper.
* **Хорошо**: PrimeNumbers.

*Пример 3*
* Плохо: Listener и Observer.
* **Хорошо**: EventTarget и EventSource.

#### Итого

Когда приходит время давать имя новому классу, думайте о том, что он *есть*, а не о том, что он *делает*.

* Он — список, и он может выбирать элементы из списка по индексу.

* Он — SQL-запись, и он может извлечь отдельную ячейку как целое число.

* Он — пиксел, и он может изменить свой цвет.

* Он — файл, и он может читать содержимое с диска.

* Он — алгоритм кодирования, и он может кодировать.

* Он — HTML-документ, и он может быть отображен.


### 1.2. Сделайте один конструктор главным

1. Конструкторов в класса должно быть больше чем методов: 2-4 метода и 5-10 конструкторов.

2. Больше конструкторов - больше гибкость, меньше методов - легче использовать класс.

3. Задача конструктора - инициализация свойств.

4. Инициализировать свойства только в одном, основном конструкторе.
Остальные конструкторы должны вызывать основной.

*Пример*:
```java
class Cash {
    private int dollars;
    Cash(float dlr) {
        this((int) dlr)
    }
    Cash(String dlr) {
        this(Cash.parse(dlr));
    }
    Cash(int dlr) {
        this.dollars = dlr;
    }
}
```

5. Основной конструктор помещается в коде после вторичных конструкторов.

6. Т.о. установка полей и возможная проверка может быть сосредоточена только
в одном месте.


### 1.3. В конструкторах не должно быть кода

1. Конструктор объекта на должен содержать код и затрагивать аргументы.

2. Инстанцирование объекта не делает ничего, кроме его сборки.

3. Реальная работа выполняется методами объекта.

*Пример 1*. Плохо:
```java
class Cash {
    private int dollars;
    Cash(String dlr) {
        this.dollars = Integer.parseInt(dir);
    }
}
```

+ Разбор числа выполняется только при создании объекта.

- Долгая инициализация.

- Неуправляемая работа - разбор происходит всегда, оптимизировать не получится.

*Пример 2*. **Хорошо**:
```java
class Cash {
    private Number dollars;
    Cash(String dlr) {      // вторичный
        this(new StringAsInteger(dlr));
    }
    Cash(Number dlr) {      // основной
        this.dollars = dlr;
    }
    int intValue() {
        return this.dollars.intValue();
    }
}
class StringAsInteger implements Number {
    private String source;
    StringAsInteger(String src) {
        this.source = src;
    }
    int intValue() {
        return Integer.parseInt(this.source);
    }
}

// Использование
Cash five = new Cash("5");      // только создается, разбора нет.
five.intValue();                // первый разбор
five.intValue();                // второй разбор
```

+ Быстрая инициализация.

+ Отложенный управляемый разбор хранимого значения. По требованию.

- Разбор строки при каждом вызове intValue().

*Решение* для последнего минуса - декоратор, выполняющий кэширование
результата:
```java
class CachedNumber implements Number {
    private Number origin;
    private Collection<Integer> cached = ArrayList<>(1);  // чтобы избежать возврата null
    public CachedNumber(Number num) {
        this.origin = num;
    }
    public int intValue() {
        if (this.cached.isEmpty()) {
            this.cached.add(this.origin.intValue());
        }
        return this.cached.get(0);
    }
}

// Использование
Number num = new CachedNumber(
    new Cash("123")
);
num.intValue();     // первый разбор строки
num.intValue();     // здесь разбора не происходит
```

*Пример 3*. Пример качественно спроектированного ПО:
```java
App app = new App(new Data(), new Screen());    // Только инициализация, без работы
app.run();                                      // Начало выполнения работы.
```


## Глава 2. Образование

### 2.1. Инкапсулируйте как можно меньше

1. Инкапсулировать не более **четырех** объектов.

2. Если нужно инкапсулировать больше объектов - класс требует рефаторинга
(разбить класс не меньшие, часть объектов включить в дополнительный класс).

3. Рекомендация (для Java) всегда переопределять метод `equals()` и избегать
оператора `==`.


### 2.2. Инкапсулируйте хотя бы что-нибудь

1. Всегда надо что-то инкапсулировать. Иначе похоже на статический метод (фу-фу).

*Пример 1*. Плохо. Класс, не инкапсулирует ничего:
```java
class Year {
    int read() {
        return System.currentTimeMillis()
            / (1000 * 60 * 60 * 24 * 30 * 12) - 1970;
    }
}
```

*Пример 2*. **Хорошо**:
```java
class Year {
    private Millis millis;
    Year(Millis msec) {
        this.millis = msec;
    }
    int read() {
        return this.millis.read()
            / (1000 * 60 * 60 * 24 * 30 * 12) - 1970;
    }
}
```


### 2.3. Всегда используйте интерфейсы

1. Использование интерфейсов - лучший инструмент для улучшения сопровождаемости.

2. Это возможность модификации объекта, не модифицируя связанные с ним объекты.

3. Все публичные методы должны реализовывать какой-либо интерфейс.

*Пример*. Использование интерфейса:
```java
interface Cash {
    Cash multiply(float factor);
}
class DefaultCash implements Cash {
    private int dollars;
    DefaultCash(int dlr) {
        this.dollars = dlr;
    }
    @Override
    Cash multiply(float factor) {
        return new DefaultCash(this.dollars * factor);
    }
}
class Employee {
    private Cash salary;
}
```


### 2.4. Тщательно выбирайте имена методов

1. Не используйте геттеры и сеттеры (см. раздел 3.5).

#### Строители — это существительные (или прилагательное + существительное)

*Строитель* - метод, который конструирует и всегда возвращает объект. Они никогда
не возвращают `void`.

*Пример 1*. Плохо: название метода глагол, который указывает объекту, что ему делать. Надо сообщить объекту, что должно быть построено.
```java
InputStream load(URL url);
String read(File file);
int add(int x, int y);
```

*Пример 2*. **Хорошо**. Надо так:
```java
InputStream stream(URL url);
String content(File file);
int sum(int x, int y);
```

*Пример 3*. **Хорошо**:
```java
int pow(int base, int power);
float speed();
Employee employee(int id);
String parsedCell(int x, int y);    // прилагательное + существительное
```

#### Не рекомендуется использовать паттерн "Строитель"

*Пример* паттерна:
```java
class Book {
    Book withAuthor(String author);     // сокращение от bookWithTitle
    Book withTitle(String title);
    Book withPage(Page page);
}
```

1. Не рекомендуется использовать паттерн "Строитель", т.к. он способствует созданию
крупных объектов, которые сложны в поддержке и намного более слабее связаны, чем
компактные.

2. Вместо использования паттерна "Строитель", стоит разбить сложные объекты
на несколько простых.

#### Манипуляторы — это глаголы (или наречие + глагол)

*Манипулятор* - метод, который изменяет сущность реального мира, абстагируемую
объектом. Всегда возвращают `void`.

*Пример 1*.
```java
class Pixel {
    void paint(Color color);    // метод-манипулятор, не возвращает результата
}

// Использование
Pixel center = new Pixel(50, 50);
center.paint(new Color("red"));
```

*Примеры*:
```java
void save(String content);
void put(String key, Float value);
void remove(Employee emp);
void quicklyPrint(int id);      // наречие + глагол
```

#### Избавление от методов строителей-манипуляторов

Не должно быть методов, которые одновременно строят и манипулируют.

*Пример 1*. Плохо:
```java
// 1. возвращает количество сохраненных байтов
int save(String content);

// 2. возвращает true, если ассоциативный массив был изменен
boolean put(String key, Float value);

// 3. изменяет скорость и возвращает ее предыдущую величину
float speed(float val);
```

*Пример 2*. **Хорошо** (переделанные предыдущие методы):

// Исправленный 1 метод.
```java
void save(String content);
// или
int bytesSaved(String content);
```

// Исправленный 2 метод. Вводится класс `PutOperation`:
```java
class PutOperation {
    private string key;
    private float value;
    private boolean success;

    PutOperation(String key, Float value) {
        this.key = key;
        this.value = value;
    }
    void save() {
        // сохраняет (используются this.key и this.value)
        // выполняется операция, устанавливается this.success
    }
    boolean success() {
        return this.success;
    }
}

// Использование. put переименовывается в putOperation
PutOperation putOperation(String key, Float value);
```

// Исправленный 3 метод. Вводится класс `SaveSpeed`:
```java
class SaveSpeed {
    private float newValue;
    ...
    SaveSpeed(float value) {
        this.newValue = value;
    }
    void save() {
        // сохраняет значение скорости
    }
    float previousSpeed() {
        // возвращает предыдущее значение скорости
    }
}
```

*Пример 3*. Плохо:
```java
class Document {
    int write(InputStream content);     // и строитель и манипулятор
}
```

**Хорошо** (переделка):
```java
class Document {
    OutPipe output();
}
class OutputPipe {
    void write(InputStream content);    // манипулятор
    int bytes();                        // строитель
    long time();                        // строитель
}
```

#### Методы, возвращающие логические значения

### 2.5. Не используйте публичные константы

#### Привнесение сцепления

#### Потеря цельности

### 2.6. Делайте классы неизменяемыми

#### Изменяемость идентичности

#### Атомарность отказов

#### Временное сцепление

#### Отсутствие побочных эффектов

#### Никаких нулевых (NULL) ссылок

#### Потокобезопасность

#### Объекты поменьше и попроще

### 2.7. Пишите тесты, а не документацию

### 2.8. Используйте fake-объекты вместо mock-объектов

### 2.9. Делайте интерфейсы краткими, используйте smart-классы

## Глава 3. Работа

### 3.1. Предоставляйте менее пяти публичных методов

### 3.2. Не используйте статические методы

Статические методы — это хуже, чем наличие константы NULL.

Статические методы ухудшают сопровождаемость программного обеспечения.

*Пример*. Без статики можно реализовать "ленивое" вычисление (статика сразу вычисляет):
```java
class Between implements Number {
  private final Number num;
  Between(Number left, Number right, Number x) {
      this.num = new Min(new Max(left, x), right);
  }
  @Override
  public int intValue() {
      return this.num.intValue();
  }
}

// Использование:
Number y = new Between(5, 9, 13);    // еще не вычисляется!
```


#### Классы-утилиты

Т.н. классы-утилиты на самом деле являются не классами, а лишь набором статических методов,
используемых другими классами для удобства (они известны также как методы-помощники).

Классы-утилиты — ужасный антипаттерн в ООП.

#### Паттерн «Синглтон»

Отличие синглтона от класса-утилиты: синглтон — это зависимость, которую можно разорвать,
а класс-утилита — жестко запрограммированная тесная связь, которую разорвать невозможно.

Иными словами, преимущество синглтонов в том, что в них можно добавить метод `setInstance()`
наряду с `getInstance()`.

*Итого:*
* «Синглтон» — ужасный антипаттерн.
* Чем заменить синглтон, если класс требуется во многих местах?
Ответ: инкапсуляция. Все, что нужно вашему классу для работы, должно быть передано посредством
конструктора и инкапсулировано внутри класса.


### 3.3. Не допускайте аргументов со значением

### 3.4. Будьте лояльным и неизменяемым либо константным

### 3.5. Никогда не используйте геттеры и сеттеры

#### Объекты против структур данных

#### Благими намерениями вымощена дорога в ад

#### Все дело в префиксах

### 3.6. Не используйте оператор new вне вторичных конструкторов

### 3.7. Избегайте интроспекции и приведения типов

## Глава 4. Уход на пенсию

### 4.1. Никогда не возвращайте NULL

#### Отказывать как можно скорее или как можно безопаснее?

#### Альтернативы NULL

### 4.2. Бросайте только проверяемые исключения

#### Не ловите исключения без необходимости

#### Стройте цепочки исключений

#### Восстанавливайтесь единожды

#### Используйте аспектно-ориентированное программирование

#### Достаточно одного типа исключений

### 4.3. Будьте либо константным, либо абстрактным

### 4.4. Используйте принцип RAII