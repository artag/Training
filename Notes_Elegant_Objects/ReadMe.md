# Элегантные объекты. Vol.1

## Глава 1. Рождение

### 1.1. Не используйте имена, заканчивающиеся на -er и -or. Не используйте Util или Utils тоже

Плохие имена: Util, Utils, Manager, Controller, Helper, Handler, Writer, Reader, Converter, Validator,
Router, Dispatcher, Observer, Listener, Sorter, Encoder и Decoder.

**Хорошие** имена: Target, EncodedText, DecodedData, Content, SortedLines, ValidPage, Source и т. п.
Также хорошо (исключения): Computer или User.

*Пример 1* вариантов имен для Cash:

* Плохо: CashFormatter.
* **Хорошо**: USDCash, CashInUSD.

*Пример 2* список простых чисел:

* Плохо: Primer, PrimeFinder, PrimeChooser, PrimeHelper.
* **Хорошо**: PrimeNumbers.

*Пример 3*:

* Плохо: Listener и Observer.
* **Хорошо**: EventTarget и EventSource.

#### Итого

Когда приходит время давать имя новому классу, думайте о том, что он *есть*, а не о том, что он *делает*.

* Он - список, и он может выбирать элементы из списка по индексу.

* Он - SQL-запись, и он может извлечь отдельную ячейку как целое число.

* Он - пиксел, и он может изменить свой цвет.

* Он - файл, и он может читать содержимое с диска.

* Он - алгоритм кодирования, и он может кодировать.

* Он - HTML-документ, и он может быть отображен.

### 1.2. Сделайте один конструктор главным

1. Конструкторов в классе должно быть больше чем методов: 2-4 метода и 5-10 конструкторов. (+ см. раздел 3.1)

2. Больше конструкторов - больше гибкость, меньше методов - легче использовать класс.

3. Задача конструктора - инициализация свойств.

4. Инициализировать свойства только в одном, основном конструкторе.
Остальные конструкторы должны вызывать основной.

*Пример*:

```java
class Cash {
    private int dollars;
    Cash(float dlr) {
        this((int) dlr)
    }
    Cash(String dlr) {
        this(Cash.parse(dlr));
    }
    Cash(int dlr) {
        this.dollars = dlr;
    }
}
```

5. Основной конструктор помещается в коде после вторичных конструкторов.

6. Т.о. установка полей и возможная проверка может быть сосредоточена только
в одном месте.

### 1.3. В конструкторах не должно быть кода

1. Конструктор объекта не должен содержать код и затрагивать аргументы.

2. Инстанцирование объекта не делает ничего, кроме его сборки.

3. Реальная работа выполняется методами объекта.

*Пример 1*. Плохо:

```java
class Cash {
    private int dollars;
    Cash(String dlr) {
        this.dollars = Integer.parseInt(dir);
    }
}
```

+ Разбор числа выполняется только при создании объекта.

- Долгая инициализация.

- Неуправляемая работа - разбор происходит всегда, оптимизировать не получится.

*Пример 2*. **Хорошо**:

```java
class Cash {
    private Number dollars;
    Cash(String dlr) {      // вторичный
        this(new StringAsInteger(dlr));
    }
    Cash(Number dlr) {      // основной
        this.dollars = dlr;
    }
    int intValue() {
        return this.dollars.intValue();
    }
}
class StringAsInteger implements Number {
    private String source;
    StringAsInteger(String src) {
        this.source = src;
    }
    int intValue() {
        return Integer.parseInt(this.source);
    }
}

// Использование
Cash five = new Cash("5");      // только создается, разбора нет.
five.intValue();                // первый разбор
five.intValue();                // второй разбор
```

+ Быстрая инициализация.

+ Отложенный управляемый разбор хранимого значения. По требованию.

- Разбор строки при каждом вызове intValue().

*Решение* для последнего минуса - декоратор, выполняющий кэширование
результата:

```java
class CachedNumber implements Number {
    private Number origin;
    private Collection<Integer> cached = ArrayList<>(1);  // чтобы избежать возврата null
    public CachedNumber(Number num) {
        this.origin = num;
    }
    public int intValue() {
        if (this.cached.isEmpty()) {
            this.cached.add(this.origin.intValue());
        }
        return this.cached.get(0);
    }
}

// Использование
Number num = new CachedNumber(
    new Cash("123")
);
num.intValue();     // первый разбор строки
num.intValue();     // здесь разбора не происходит
```

*Пример 3*. Пример качественно спроектированного ПО:

```java
App app = new App(new Data(), new Screen());    // Только инициализация, без работы
app.run();                                      // Начало выполнения работы.
```

## Глава 2. Образование

### 2.1. Инкапсулируйте как можно меньше

1. Инкапсулировать не более **четырех** объектов.

2. Если нужно инкапсулировать больше объектов - класс требует рефаторинга
(разбить класс не меньшие, часть объектов включить в дополнительный класс).

3. Рекомендация (для Java) всегда переопределять метод `equals()` и избегать
оператора `==`.

### 2.2. Инкапсулируйте хотя бы что-нибудь

1. Всегда надо что-то инкапсулировать. Иначе похоже на статический метод (фу-фу).

*Пример 1*. Плохо. Класс, не инкапсулирует ничего:

```java
class Year {
    int read() {
        return System.currentTimeMillis()
            / (1000 * 60 * 60 * 24 * 30 * 12) - 1970;
    }
}
```

*Пример 2*. **Хорошо**:

```java
class Year {
    private Millis millis;
    Year(Millis msec) {
        this.millis = msec;
    }
    int read() {
        return this.millis.read()
            / (1000 * 60 * 60 * 24 * 30 * 12) - 1970;
    }
}
```

### 2.3. Всегда используйте интерфейсы

1. Использование интерфейсов - лучший инструмент для улучшения сопровождаемости.

2. Это возможность модификации объекта, не модифицируя связанные с ним объекты.

3. Все публичные методы должны реализовывать какой-либо интерфейс.

*Пример*. Использование интерфейса:

```java
interface Cash {
    Cash multiply(float factor);
}
class DefaultCash implements Cash {
    private int dollars;
    DefaultCash(int dlr) {
        this.dollars = dlr;
    }
    @Override
    Cash multiply(float factor) {
        return new DefaultCash(this.dollars * factor);
    }
}
class Employee {
    private Cash salary;
}
```

### 2.4. Тщательно выбирайте имена методов

1. Не используйте геттеры и сеттеры (см. раздел 3.5).

#### 2.4.1. Строители - это существительные (или прилагательное + существительное)

*Строитель* - метод, который конструирует и всегда возвращает объект. Они никогда
не возвращают `void`.

*Пример 1*. Плохо: название метода глагол, который указывает объекту, что ему делать. Надо сообщить объекту, что должно быть построено.

```java
InputStream load(URL url);
String read(File file);
int add(int x, int y);
```

*Пример 2*. **Хорошо**. Надо так:

```java
InputStream stream(URL url);
String content(File file);
int sum(int x, int y);
```

*Пример 3*. **Хорошо**:

```java
int pow(int base, int power);
float speed();
Employee employee(int id);
String parsedCell(int x, int y);    // прилагательное + существительное
```

#### Не рекомендуется использовать паттерн "Строитель"

*Пример* паттерна:

```java
class Book {
    Book withAuthor(String author);
    Book withTitle(String title);       // сокращение от bookWithTitle
    Book withPage(Page page);
}
```

1. Не рекомендуется использовать паттерн "Строитель", т.к. он способствует созданию
крупных объектов, которые сложны в поддержке и намного более слабее связаны, чем
компактные.

2. Вместо использования паттерна "Строитель", стоит разбить сложные объекты
на несколько простых.

#### 2.4.2. Манипуляторы - это глаголы (или наречие + глагол)

*Манипулятор* - метод, который изменяет сущность реального мира, абстагируемую
объектом. Всегда возвращают `void`.

*Пример 1*.

```java
class Pixel {
    void paint(Color color);    // метод-манипулятор, не возвращает результата
}

// Использование
Pixel center = new Pixel(50, 50);
center.paint(new Color("red"));
```

*Примеры*:

```java
void save(String content);
void put(String key, Float value);
void remove(Employee emp);
void quicklyPrint(int id);      // наречие + глагол
```

#### Избавление от методов строителей-манипуляторов

Не должно быть методов, которые одновременно строят и манипулируют.

*Пример 1*. Плохо:

```java
// 1. возвращает количество сохраненных байтов
int save(String content);

// 2. возвращает true, если ассоциативный массив был изменен
boolean put(String key, Float value);

// 3. изменяет скорость и возвращает ее предыдущую величину
float speed(float val);
```

*Пример 2*. **Хорошо** (переделанные предыдущие методы):

// Исправленный 1 метод.

```java
void save(String content);
// или
int bytesSaved(String content);
```

// Исправленный 2 метод. Вводится класс `PutOperation`:

```java
class PutOperation {
    private string key;
    private float value;
    private boolean success;

    PutOperation(String key, Float value) {
        this.key = key;
        this.value = value;
    }
    void save() {
        // сохраняет (используются this.key и this.value)
        // выполняется операция, устанавливается this.success
    }
    boolean success() {
        return this.success;
    }
}

// Использование. put переименовывается в putOperation
PutOperation putOperation(String key, Float value);
```

// Исправленный 3 метод. Вводится класс `SaveSpeed`:

```java
class SaveSpeed {
    private float newValue;
    ...
    SaveSpeed(float value) {
        this.newValue = value;
    }
    void save() {
        // сохраняет значение скорости
    }
    float previousSpeed() {
        // возвращает предыдущее значение скорости
    }
}
```

*Пример 3*. Плохо:

```java
class Document {
    int write(InputStream content);     // и строитель и манипулятор
}
```

**Хорошо** (переделка):

```java
class Document {
    OutPipe output();
}
class OutputPipe {
    void write(InputStream content);    // манипулятор
    int bytes();                        // строитель
    long time();                        // строитель
}
```

#### 2.4.3. Методы, возвращающие логические значения - это прилагательные

1. Методы, возвращающие логические значения - это строители. Для лучшей
читаемости их имена надо делать прилагательными.

2. Префикс *is* избыточен и не должен использоваться явно.

*Примеры*:

```java
boolean empty();        // is empty
boolean readable();     // is readable
boolean negative();     // is negative

boolean equalTo(Object obj);    // Вместо equals(Object obj);
boolean present();              // Вместо exists();
```

### 2.5. Не используйте публичные константы (и enum тоже)

Ипользование публичных констант:

**+** Решает проблему дублирования кода

#### 2.5.1. Привнесение сцепления

**-** Где применяется константа? Как и на что повлияет изменение ее значения?

#### 2.5.2. Потеря цельности

**-** Константа "не знает" о своей миссии, о своем назначении.

#### Решение

1. Объекты не должны совместно использовать данные.

2. Вместо константы надо создавать новые классы.

**+** Сцепление посредством контракта (классы можно разъединить).

**+** Можно изменить поведение "константы-класса", не меняя его интерфейс.

*Пример 1*.

```java
// Перевод константы в класс
class EOLString {
    private final String origin;
    EOLString(String src) {
        this.origin = src;
    }
    @Override
    String toString() {
        return String.format("%s\r\n", origin);
    }
}

// Использование
class Records {
    void write(Writer out) {
        for (Record rec : this.all) {
            out.write(new EOLString(rec.toString()));
        }
    }
}
```

*Пример 2*. Плохо:

```java
String body = new HttpRequest()
    .method(Http.Methods.POST)  // Статический строковый литерал "POST"
    .fetch();
```

**Хорошо**:

```java
String body = new PostRequest(new HttpRequest())
    .fetch();
```

### 2.6. Делайте классы неизменяемыми

Неизменяемость делает классы:

* Небольшими
* Цельными
* Рацепленными
* Хорошо сопровождаемыми

*Пример 1.* Неизменяемый класс.

```java
class Cash {
    private final int dollars;      // Инициализация только в конструкторе
    Cash(int val) {
        this.dollars = val;
    }
    public Cash mul(int factor) {
        return new Cash(this.dollars * factor);     // Новый объект
    }
}

// Использование
Cash five = new Cash(5);
Cash fifty = five.mul(10);
```

#### Решаемые проблемы, если объект неизменяем

* Изменяемость идентичности.

* Атомарность отказов. Либо полный и целостный объект, либо отказ. Никаких
промежуточных состояний.

```java
class Cash {
    private final int dollars;
    private final int cents;
    public Cash mul(int factor) {
        if (/* что-то не так */) {
            throw new RuntimeException("ой...");
        }
        return new Cash(
            this.dollars * factor,
            this.cents * factor
        );
    }
}
```

* Временное сцепление. Инициализация объекта и его инстанцирование
происходят в один момент времени.

```java
Cash price = new Cash();
price.setDollars(29);
System.out.println(price);  // "$29.00"!
price.setCents(95);
```

* Отсутствие побочных эффектов.

* Никаких нулевых (NULL) ссылок.

Плохо:

```java
class User {
    private final int id;
    // В неизменяемом объекте, такого поля не будет
    private String name = null;
    public User(int num) {
        this.id = num;
    }
    public void setName(String txt) {
        this.name = txt;
    }
}
```

* Потокобезопасность.

* Объекты поменьше и попроще.
  * Типичный (рекомендуемый) размер - не более **250 строк**.
  * Сопровождаемость.
  * Тяжело сделать неизменяемый объект слишком большим.

### 2.7. Пишите тесты, а не документацию

1. Пишите простой легко читаемый код.

2. Простой код говорит сам за себя и не требует дополнительной документации.

3. Плохие классы вынуждают писать для них документацию.

4. Не документируйте код, а делайте его чище.

5. Юнит-тест и есть документация. Он показывает как использовать класс.

6. Уделяйте юнит-тестам такое же внимание, как и основному коду.

### 2.8. Используйте fake-объекты вместо mock-объектов

1. Мокинг - плохая практика.

2. Мокинг превращает предположения в факты. Мы должны знать, что вызовет
тестируемый класс у подстановочного mock класса, чтобы сделать замещение
у нужного метода.

3. Мокинг привязывает тесты к внутренним деталям реализации класса.

4. Вместо мокинга задействовать fake-объекты. Причем, fake-объект должен
поставляться вместе с интерфейсом.

*Пример*. (Не самый удачный, но суть видно):

```java
interface Exchange {
    float rate(String origin, String target);
    final class Fake implements Exchange {
        @Override
        float rate(String origin, String target) {
            return 1.2345;
        }
    }
}

// Использование
Exchange exchange = new Exchange.Fake();
Cash dollar = new Cash(exchange, 500);
Cash euro = dollar.in("EUR");
assert "6.17".equals(euro.toString());
```

5. Работая с интерфейсом и создавая для него fake-класс, вы неизбежно
вынуждены думать как пользователь интерфейса, а не только как его
разработчик.

#### Рекомендации по созданию fake-классов

* Оснастить свои интерфейсы fake-классами.

* Убедиться, что все классы не имеют методов, не реализующих интерфейс
(см. раздел 2.3).

### 2.9. Делайте интерфейсы краткими, используйте smart-классы

1. Важно делать интерфейсы небольшими.

2. Вместо расширения интерйфейса используйте smart-класс внутри него.

3. Функционал smart-класса может быть совместно использован несколькими
классами.

4. Smart-класс может содержать очень большое количество методов.

5. Smart-классы неидеальные объекты. Они являются инструментами,
помогающими создавать хорошие объекты.

*Пример*. Избыточный интерфейс:

```java
interface Exchange {
    float rate(String target);
    float rate(String source, String target);
}
```

*Решение*. Использовать smart-класс внутри интерфейса.

```java
interface Exchange {
    float rate(String source, String target);

    final class Smart {
        private final Exchange origin;
        public float toUsd(String source) {
            return this.origin.rate(source, "USD");
        }
        public float eurToUsd() {
            return this.toUsd("EUR");
        }
    }
}

// Использование
float rate = new Exchange.Smart(new NYSE()).toUsd("EUR");
float rate = new Exchange.Smart(new NYSE()).eurToUsd();
```

## Глава 3. Работа

### 3.1. Предоставляйте менее пяти публичных (и защищенных) методов

1. Из раздела 1.2: конструкторов в классе должно быть больше чем методов:
2-4 метода и 5-10 конструкторов.

2. Из раздела 2.6: класс должен быть менее чем 250 строк.

3. Здесь добавляется еще ограничение - не более 5 публичных/защищенных
методов.

Достоинства малых по размеру классов.

* Более элегантны. (Меньше вероятность сделать ошибку).

* Лучше сопровождаются

* Более цельные.

* Более верифицируемы.

### 3.2. Не используйте статические методы

Статические методы - это хуже, чем наличие константы NULL.

Статические методы ухудшают сопровождаемость программного обеспечения.

*Пример*. Без статики можно реализовать "ленивое" вычисление (статика сразу вычисляет):

```java
class Between implements Number {
  private final Number num;
  Between(Number left, Number right, Number x) {
      this.num = new Min(new Max(left, x), right);
  }
  @Override
  public int intValue() {
      return this.num.intValue();
  }
}

// Использование:
Number y = new Between(5, 9, 13);    // еще не вычисляется!
```

#### 3.2.1. Классы-утилиты

Т.н. классы-утилиты на самом деле являются не классами, а лишь набором статических методов,
используемых другими классами для удобства (они известны также как методы-помощники).

Классы-утилиты - ужасный антипаттерн в ООП.

* Мы не можем собирать крупные объекты из более мелких с применением  статических методов.
*(Прим.: Кстати, почему?)*

* Не используйте в коде ключевое слово `static`.

#### 3.2.2. Паттерн «Синглтон»

Отличие синглтона от класса-утилиты: синглтон - это зависимость, которую можно разорвать,
а класс-утилита - жестко запрограммированная тесная связь, которую разорвать невозможно.

Иными словами, преимущество синглтонов в том, что в них можно добавить метод `setInstance()`
наряду с `getInstance()`.

*Итого:*

* «Синглтон» - ужасный антипаттерн.

* Чем заменить синглтон, если класс требуется во многих местах?
Ответ: инкапсуляция. Все, что нужно вашему классу для работы, должно быть передано посредством
конструктора и инкапсулировано внутри класса.

#### 3.2.3. Функциональное программирование (ФП)

*Примечание: какая-то невнятная глава.*

Преимущества ООП над ФП:

* ООП более выразительно.

* ООП оперирует объектами и методами, ФП - лишь функциями.

Идеальный ООП: классы с функциями внутри (которые имеют единственную точку выхода,
как в функциональной парадигме).

#### 3.2.4. Компонуемые декораторы

**Компонуемые декораторы** - объекты-обертки над другими объектами. Они становятся *компонуемыми*,
когда мы объединяем их в многослойные структуры.

*Пример*.

```java
names = new Sorted(
    new Unique(
        new Capitalized(
            new Replaced(
                new FileNames(
                    new Directory(
                        "/var/users/*.xml"
                    )
                ),
                "([^.]+)\\.xml",
                "$1"
            )
        )
    )
);
```

Все эти классы - компонуемые декораторы.

**Принципы компоновки**:

* Классы могут реализовывать тот же интерфейс, что и инкапсулированные объекты (но это необязательно).

* Каждый компонуемый декоратор добавляет некоторое поведение инкапсулированным объектам.

* Код должен состоять из такой "пирамиды" объектов.

* Не должно быть процедурных операторов вроде `if`, `for`, `switch` и `while`.

*Еще пример*. Превращение процедурного кода в объектно-ориентированный:

```java
// процедурный код
float rate;
if (client.age() > 65) {
    rate = 2.5;
}
else {
    rate = 3.0;
}

// он же, но объектно-ориентированный
float rate = new If(
    new GreaterThan(
        new AgeOf(client),
        65
    ),
    2.5, 3.0
);
```

### 3.3. Не допускайте аргументов со значением NULL

#### Обертка объекта для его передачи в метод без использования NULL

*Пример*. Плохо.

```java
public Iterable<File> find(String mask) {
    if (mask == null) {         // Дурной тон
        // найти все файлы
    } else {
        // найти файлы по маске
    }
}
```

*Пример*. Лучше.

```java
public Iterable<File> find(Mask mask) {
    if (mask.empty()) {
        // найти все файлы
    } else {
        // найти файлы по маске
    }
}
```

*Пример*. **Хорошо**.

```java
public Iterable<File> find(Mask mask) {
    Collection<File> files = new LinkedList<>();
    for (File file : /* все файлы */) {
        if (mask.matches(file)) {
            files.add(file);
        }
    }
    return files;
}
```

#### Передача в метод нулевого объекта

```java
interface Mask {
    boolean matches(File file);
}

// Нулевой объект
class AnyFile implements Mask {
    @Override
    boolean matches(File file) {
        return true;
    }
}
```

#### Если в метод все же передается NULL. Две стратегии поведения

* **Оборонительная стратегия**. Проверка аргумента на NULL и выброс исключения.

```java
public Iterable<File> find(Mask mask) {
    if (mask == null) {
        throw new IllegalArgumentException("Маска не может быть NULL");
    }
    // Найти файлы по маске и вернуть результат.
}
```

* **Стратегия игнорирования**. Рекомендуется. Рано или поздно будет
выброшено исключение `NullPointerException`.

### 3.4. Будьте лояльным и неизменяемым либо константным

У каждого объекта есть три элемента:

1. Идентичность - что отличает данный объект от других объектов.

2. Состояние - что объект знает о том, что он хранит (например, файл на диске).

3. Поведение - что объект может сделать по запросу.

* Константный объект:
  * Имеет **неизменяемое состояние**.
  * Может иметь неуникальную идентичность (может не отличаться от других объектов (например, переопределение `equals`))
  * Может иметь изменяемое поведение (например, файл на диске изменился - теперь читаются другие данные).

* Лучше использовать константные объекты, т.к. они проще для проектирования, поддержки и понимания.

### 3.5. Никогда не используйте геттеры и сеттеры

1. Хороший класс не позволяет получать доступ к своим полям.
Он черный ящик.

2. Геттеры и сеттеры нарушают принцип инкапсуляции.

3. Префикс `get` вреден (см. раздел 2.4).

4. С точки зрения пользователя, геттеры и сеттеры представляют данные, а не поведение.

5. Геттеры и сеттеры - ужасный антипаттерн ООП.

#### Объекты против структур данных

Пример структуры данных - DTO.

* Структура данных - мешок с данными, класс - не дает прямого доступа к своим полям.

* Структуры данных прозрачны, объекты - нет.

* Структуры данных склоняют к применению процедурного стиля программирования.

### 3.6. Не используйте оператор new вне вторичных конструкторов

Не используйте оператор new внутри основного конструктора.

*Пример 1*. Плохо.

```java
class Cash {
    private final int dollars;
    public int euro() {
        return new Exchange().rate("USD", "EUR") * this.dollars;
    }
}
```

Что плохо: нельзя разорвать связь между классами Cash и Exchange.

Решение:

1. Объекты могут принимать новые объекты только в качестве аргументов
конструктора и инкапсулировать в приватных полях.

2. Не используйте оператор `new` нигде, кроме вторичных конструкторов.
Благодаря этому объекты будут полностью расцеплены.

3. Оператор `new` нельзя использовать даже внутри основного конструктора.

*Пример 1*. **Хорошо**:

```java
class Cash {
    private final int dollars;
    private final Exchange exchange;
    Cash() {                            // вторичный конструктор
        this(0);
    }
    Cash(int value) {                   // вторичный конструктор
        this(value, new NYSE());
    }
    Cash(int value, Exchange exch) {    // основной конструктор
        this.dollars = value;
        this.exchange = exch;
    }
    public int euro() {
        return this.exchange.rate("USD", "EUR") * this.dollars;
    }
}
```

*Пример 2*. Плохо. Код, который должен инстанцировать объекты.

```java
class Requests {
    private final Socket socket;
    public Requests(Socket skt) {
        this.socket = skt;
    }
    public Request next() {
        return new SimpleRequest(           // использование new!
            // Прочесть данные из сокета
        )
    }
}
```

*Пример 2*. **Хорошо**.

```java
class Requests {
    private final Socket socket;
    private final Mapping<String, Request> mapping;
    public Requests(Socket skt) {
        this(
        skt,
        new Mapping<String, Request>() {
            @Override
            public Request map(String data) {
                return new SimpleRequest(data);
            }
        });
    }
    public Requests(Socket skt, Mapping<String, Request> mpg) {
        this.socket = skt;
        this.mapping = mpg;
    }
    public Request next() {
        return this.mapping.map(
            // Прочесть данные из сокета
        );
    }
}
```

### 3.7. Избегайте интроспекции (рефлексии) и приведения типов

1. Рефлексия - хороший инструмент для плохих программистов.

2. Приведение типов - по сути принуждение объекта подчиниться контракту,
по выполнение которого он не подписывался.

## Глава 4. Уход на пенсию

### 4.1. Никогда не возвращайте NULL

1. Причины возврата NULL - подход "как можно безопаснее".
Возвращение NULL - прием выживания.

#### 4.1.1. Альтернативы NULL (3 подхода)

1. Отказывать как можно скорее (подход скорейшего отказа)

  * Остановить выполнение и выбросить исключение, как только мы столкнемся с проблемой (любой!)

  * Такой подход в итоге повышает качество всего приложения в целом.

2. Если что-то не найдено - возврат пустой коллекции.

*Пример 1*. Плохо.

```java
public User user(String name) {
    if (/* имя не найдено в базе данных */) {
        return null;
    }
    return /* запись из базы данных */;
}
```

*Пример 1*. **Хорошо**.

```java
public Collection<User> users(String name) {
    if (/* имя не найдено в базе данных */) {
        return new ArrayList<>(0);
    }
    return Collections.singleton(
        /* из базы данных */
    );
}
```

3. Паттерн "пустой объект".

Когда искомый объект не найден, возвращается объект, похожий на настоящий,
но ведущий себя по-другому (он может делать что-то одно, но не делать
что-то другое).

*Пример*:

```java
class NullUser implements User {
    private final String label;
    NullUser(string name) {
        this.label = name;
    }
    @Override
    public String name() {
        return this.label;
    }
    @Override
    public void raise(Cash salary) {
        throw new IllegalStateException("Пользователь-заглушка");
    }
}
```

4. **Не рекомендуется**. Применение generic-класса `java.util.Optional`.

Похож на коллецию, но содержит 1 элемент. Это решение противоречит
принципам ООП и не рекомендуется использовать его, т.к. оно семантически
некорректно.

Метод называется `user()`, но возвращает "конверт" с пользователем, что сбивает с толку и
не соответствует духу ООП.

### 4.2. Бросайте только проверяемые исключения

Для проверяемых исключений компилятор заранее проверяет код на их
наличие. Если он их найдет, то не скомпилирует код, пока мы не обработаем исключения или не пробросим их наверх.

1. Непроверяемые исключения - недостаток языка, все исключения должны
быть проверяемыми.

2. Проверяемые исключения всегда на виду.

3. Если метод может кинуть непроверяемое исключение, то очень
большая вероятность, что исключение будет неверно обработано.

#### 4.2.1. Не ловите исключения без необходимости

1. Не ловите исключения без особой необходимости, делайте это, только
если у вас нет другого выбора.

2. Идеальное приложение - на каждую точку входа есть единственный блок
`catch`.

3. Использовать быстрый отказ. Не прятать проблему, а пробрасывать
исключение наверх.

4. Исключения не для замены условных операторов. Они должны обозначать
критическую ситуацию, не допускающую восстановления.
В результате возникновения которой прекращается нормальное исполнение
программы и нужно принимать чрезвычайные меры.

5. Поимка исключения и спасение ситуации - действия, которые должны
иметь под собой серьезную причину. Это подход безопасного отказа.

6. Ловить и записывать в журнал - **ужасный антипаттерн**.

#### 4.2.2. Стройте цепочки исключений

1. Пойманное исключение оборачивается в новое и пробрасывается выше.

2. После нескольких раз, всплывшее исключение будет содержать в себе
много слоев из внутренних исключений.

3. Самый верхний catch сможет достать все "обернутые" исключения,
благодаря чему легко можно отследить источник проблемы.

4. В идеале каждый метод должен ловить все возможные исключения и
перебрасывать их, формируя цепочки исключений.

*Пример*:

```java
public int length(File file) throws Exception {
    try {
        return content(file).length();
    } catch (IOException ex) {
        throw new Exception("Невозможно определить размер файла.", ex);
    }
}
```

#### 4.2.3. Восстанавливайтесь единожды и только на верхнем уровне

1. Всем методам должно быть разрешено перебрасывать исключения, не обрабатывая
их (см. предыдущий раздел).

2. Все исключения всплывают:

  * на верхний уровень приложения.

  * к точкам входа в приложение.

  * к точкам, через которые пользователь общается с приложением.

3. На верхнем уровне исключения обрабатываются (ничего не перебрасывается).

4. Количество таких "законных" мест для восстановления в приложении обычно
невелико.

#### 4.2.4. Используйте аспектно-ориентированное программирование

*Пример*. Плохо. Повтор загрузки веб-страницы посредством HTTP-запроса:

```java
public String content() throws IOException {
    int attempt = 0;
    while (true) {
        try {
            return http();
        } catch (IOException ex) {
            if (attempt >= 2) {
                throw ex;
            }
        }
    }
}
```

Данный пример противоречит предыдущему разделу.

Есть только одно решение - *аспектно-ориентированное программирование* (АОП).

*Пример*. **Хорошо**. Тоже, но с использованием АОП:

```java
@RetryOnFailure(attemts = 3)        // повторить при ошибке (макс. 3 раза)
public String content() throws IOException {
    return http();
}
```

*Ссылка* с информацией по АОП: http://aspects.jcabi.com

#### 4.2.5. Достаточно одного типа исключений

1. Типизация исключений избыточна из-за (из предыдущих разделов):

  * восстанавливаемся лишь единожды

  * объект исключения содержит вложенные исключения

  * исключения ловятся с целью их пробрасывания выше

  * информация о типе исключения не нужна, т.к. она нигде не используется

### 4.3. Классы либо константные (нельзя от них наследовать), либо абстрактные

1. Наследование делает отношения между объектами слишком запутанными.
(Методы одного класса могут быть вызваны из разных иерархий классов).

2. Рекомендуется использовать классы:

  * константные (от них нельзя наследовать, методы не переопределяются)

  * абстрактные (переопределяются некоторые методы, остальные методы константные)

*Пример*. Что использовать вместо наследования.

Вместо наследования - определяется интерфейс и создаются требуемые классы.

```java
interface Document {
    int length();
    byte[] content();
}

final class DefaultDocument implements Document {    // константный класс
    @Override
    public int legth() { /*...*/ }
    @Override
    public byte[] content() { /*...*/ }
}

final class EncryptedDocument implements Document {
    private final Document plain;       // вместо наследования
    EncryptedDocument(Document doc) {
        this.plain = doc;
    }
    @Override
    public int length() {
        return this.plain.length();
    }
    @Override
    public byte[] content() {
        byte[] raw = this.plain.content();
        /* Дополнительный функционал по расшифровки содержимого */
    }
}
```

3. Рекомендуется помечать классы с помощью ключевых слов *final* или *abstract*.

4. Наследование использовать только для абстрактного класса, когда требуется
**уточнить** поведение класса (а не изменить его).

*Пример*. Уточнение поведения:

```java
abstact class Document {
    public abstract byte[] content();
    public final int length() {
        return this.content().length;
    }

final class DefaultDocument extends Document {
    @Override
    public byte[] content {                 // уточнения поведения 1
        // Загружает содержимое с диска
    }
}

final class EncryptedDocument extends Document {
    @Override
    public byte[] content() {               // уточнение поведения 2
        // Загружает содержимое с диска,
        // расшифровывает и возвращает его
    }
}
```

### 4.4. Используйте принцип RAII

1. RAII (Resource Acquisition Is Initialization) - принцип:
"выделение ресурсов есть инициализация".

2. По сути, это вызов `dispose()`, `close()` и других подобных методов на
объектах, которые уже не нужны.

3. В C++ эту задачу выполняют деструкторы, в Java - интерфейс `AutoCloseable`.

*Пример*.

```java
int main() {
    try (Text t = new Text("/tmp/test.txt")) {
        t.content();
    }
}
```

# Элегантные объекты. Vol.2

## Gray

Глава 5 описывает сущности, действия и т.п. вещи, которые *вредят* ООП.
Описываемое хотя и не фатально, но нежелательно к использованию.

### 5.1. Compound (составные) names (или имена переменных должны быть простыми)

Правила именования классов и методов объяснялись в главах 1.1 и 2.4.

Здесь говориться как грамотней называть переменные.

1. Имена переменных должны быть в виде существительного, без уточняющих слов. **Можно** (пример):
`file`, `array`, `index`, `user`, `url`, `target`, `stream`, `position`, `config`, `jeff`, `google`.

2. Есть существительные, смысл которых теряется без прилагательной части. **Можно** (пример):
`timeZone`, `side-effect`, `MicroService`, `ChangingRoom`, `washing_machine`, `busStop`,
`laughing-gas`.

3. Не называть переменные составными именами: `day_of_year`, `utfEncodedFile`, `encodedArray`,
`decodedArray`.

4. Если код, который мы пишем, не понятен с использованием коротких имен переменных, значит:

  * Требуется уменьшить видимость переменной.

  * Разбить код на более мелкие части.

5. Короткие, одиночные имена более читаемы.

6. Появление составных имен переменных - верный признак, что код требует рефакторинга.

### 5.2. Validators and assertions (Валидаторы и утверждения)

В главе 4.1.1 было утверждение: чтобы сделать стабильное ПО, требуется, чтобы оно было как
можно более хрупким.

Любое ПО имеет бесконечное число багов. Задача обнаружить их как можно больше и "доставить" их
пользователю как можно меньше.

Обнаружение багов должно быть как можно более простым ("дешевым"). Для этого необходимо делать
ПО как можно более *хрупким* - при любом подозрении на ошибку ПО должно сообщать об этой
ошибке пользователю.

#### Режимы работы при аварийных ситуациях

* **fail safe**. Ошибка прячется, пытаемся прожолжить работу. Плохой подход.

* **fail fast**. Аварийное завершение работы с сообщением об ошибке. Предпочтительный подход.

#### Варианты сообщений об авариях в ПО

* При continuous integration и тестировании должно быть много технических логов.

* В staging environment можно скрывать некоторые технические данные в логах, но добавить
информацию для manual testers о техподдержке.

* В конечном продукте тенические детали свести к минимуму, но предоставить пользователю
максимально возможную информацию куда и как обращаться за техподдержкой.

#### Два способа обеспечения хрупкости ПО

1. Выброс исключения. Предпочтительный вариант.

2. Assertions. Менее предпочтителен. (Менее заметен в коде - может быть случайно удален).

#### Два места где проверяются подозрительные данные

1. Входные данные

2. Предположения, после вычисления данных

Пример:

```java
// Проверка входных данных (input validation).
int daysBetween(Date start, Date end) {
    if (start.compareTo(end) > 0) {
        throw new IllegalArgumentException(String.Format(
            "Start (%s) must be earlier than end (%s)", start, end));
    }
    return (int)((end.getTime() - start.getTime() / (24 * 60 * 60 * 1000L)));
}


// Предположение (assertion), после вычисления дней, перед casting в int.
int daysBetween(Date start, Date end) {
    final long days = (end.getTime() - start.getTime())
        / (24 * 60 * 60 * 1000L);
    if (days > Integer.MAX_VALUE) {
        throw new IllegalArgimentException(String.Format(
            "Distance btwn %s and %s is bigger than INT", start, end));
    }
    return (int)days;
}
```

**НО**: Проверки засоряют код - их становиться слишком много. Выход:
использование validating decorators и assertions with object.

Дополнительный плюсы использования последних - гибкость (отключение, если требуется высокая
производительность, расширяемость, тестируемость).

#### Validating decorators (input validation)

```java
interface Day {
    int distanceTo(Day end)
}

// Чистый класс, без проверок.
class JdkDay implements Day {
    private final Date date;
    JdkDate(Date d) {
        this.date = d;
    }
    @Override
    public int distanceTo(Day end) {
        return (int) ((end.date.getTime() - this.date.getTime())
            / (24 * 60 * 60 * 1000L));
    }
}

// Проверка входных параметров, validating decorator
class StrictDay implements Day {
    private final Day origin;
    StrictDay (Day d) {
        this.origin = d;
    }
    @Override
    public int distanceTo(Day end) {
        if (end.compareTo(this) < 0) {
            throw new IllegalArgumentException(
                "Start (%s) must be earlier than end (%s)", this, end);
        }
        return this.origin.distanceTo(end);
    }
}
```

#### Assertions with object

*Предположение* (assertion) делается с использованием стороннего объекта класса `LongAsInteger`.

```java
class JdkDay implements Day {
    private final Date date;
    JdkDate(Date d) {
        this.date = d;
    }
    @Override
    public int distanceTo(Day end) {
        return new LongAsInteger(
            (end.date.getTime() - this.date.getTime()) / (24 * 60 * 60 * 1000L)
        ).intValue();
    }
}
```

Объект класса `LongAsInteger` при неудачном casting `long` в `int` выбросит исключение.

### 5.3. Printers instead of getters

В главе 3.5 было объяснено почему использование геттеров и сеттеров в классах это очень плохо.
Кратко почему:

* Объекты превращаются в контейнеры данных, мешки данных и т.п.

* Объекты из "черного ящика" превращаются "стеклянный ящик".

Каким образом избегать сеттеров понятно, но, что же использовать вместо геттеров?

Ответ: **принтеры**. Объект сам себя должен печатать по просьбе внешнего объекта (или в сам внешний объект).

Пример (еще не идеальный, но уже ближе к нему):

```java
class Book {
    private final String isbn;
    private final String title;
    private final String author;
    Book(String i, String t, String a) {    // альтернатива сеттерам (конструктор)
        this.isbn = i;
        this.title = t;
        this.author = a;
    }
    String print(Page page, String prefix) {    // альтернатива геттерам
        return page
            .with(prefix + ".isbn", this.isbn)
            .with(prefix + ".title", this.title)
            .with(prefix + ".author", this.author)
            .html();
    }
}

// Использование
Book book = database.fetch(123);
Page page = new Page("book.html");
String html = book.print(page, "b");    // "Печать" книги на page.
```

#### 5.3.1. - 5.3.3 Single Responsibility Principle, God object, Code duplication

Но, что если надо "печатать" объект не только на страницу (page) в html, но и отобразить данные
в виде JSON, байтового массива, XML, и т.д.:

```java
class Book {
    ...
    void printToPage(Page page) { /*...*/ }
    byte[] printToByteArray) { /*...*/ }
    JsonObject printToJSON() { /*...*/}
    ...
}
```

Т.е. класс начинает увеличиваться в размерах: все более уходит от состояния "Solid", больше начинает
походить на God object. Плюс, увеличивается вероятность дублирования кода.

Но, как утверждает автор, уж лучше это чем нарушение инкапсуляции объекта, вызванного использованием
геттеров и сеттеров.

Но есть более изящные решения: см. 5.3.4 и 5.3.5 (The best).

#### 5.3.4. Utility objects

Решение #1. Использование служебных неизменяемых объектов. Вся самая тяжелая функциональность
выносится в отдельные служебные классы. Уже лучше, но не идеально. Лучше смотреть решение 5.3.5.

```java
class Book {
    Book(String i, String t, String a) {    // конструктор
        ...
    }
    String printToJSON() throws IOException {
        return new JSONPage()                   // служебный класс
            .with(prefix + ".isbn", this.isbn)
            .with(prefix + ".title", this.title)
            .with(prefix + ".author", this.author)
            .json();
    }
}

class JSONPage implements Page {                // immutable class
    private final Map<String, String> attrs;
    JSONPage() {                                // второй конструктор
        this(new HashMap<String, String>());
    }
    JSONPage(Map<String, String map> map) {     // главный конструктор
        this.attrs = map;
    }
    @Override
    public Page with(String name, String value) {
        Map<String, String> map = new HashMap<>();
        map.putAll(this.attrs);
        map.put(name, value);
        return new JSONPage(map);
    }
    String json() {
        // ...
    }
}

```

#### 5.3.5. Polymorphic media

Решение #2. Использовать полиморфизм. Самое элегантное решение.

```java
interface Media {
    Media with(String k, String v);
    byte[] bytes();
}

class Book {
    Book(String i, String t, String a) {
        ...
    }
    byte[] printTo(Media media) {       // Один общий принтер
        return media
            .with(prefix + ".isbn", this.isbn)
            .with(prefix + ".title", this.title)
            .with(prefix + ".author", this.author)
            .bytes();
    }
}

class ToPacket implements Media {       // Первый принтер
    private final Packet packet;
    ToPacket(Packet p) {
        this.packet = p;
    }
    @Override
    public Media with(String name, String value) {
        return new ToPacket(
            this.packet.add(value.getBytes())
        );
    }
    @Override
    public byte[] bytes() {
        // ..
    }
}

class ToJSON implements Media {         // Второй принтер
    private final JSONPage page;
    ToJSON() {
        this(new JSONPage())
    }
    ToJSON(JSONPage p) {
        this.page = p;
    }
    @Override
    public Media with(String name, String value) {
        return new JSON(this.page.with(name, value));
    }
    @Override
    public byte[] bytes() {
        // ..
    }
}
```

Использование:

```java
Media media = new ToPacket();
byte[] bytes = book.printTo(media);
```

или

```java
Media media = new ToJSON();
byte[] bytes = book.printTo(media);
```

#### 5.3.6. Polymorphic media (ver 2 - from site)

Или сделать так (что еще лучше). **Окончательный вариант**:

```java
public class Book {
  Book(String isbn, String title) {
      ...
  }
  public Media print(Media media) {     // Принимает и возвращает Media
    return media
      .with("isbn", this.isbn)
      .with("title", this.title);
  }
}

class JsonMedia implements Media {      // Реализация Media (одна из)
  private final JsonObjectBuilder builder;
  JsonMedia() {
    this("book");
  }
  JsonMedia(String head) {
    this(Json.createObjectBuilder().add(head));
  }
  JsonMedia(JsonObjectBuilder bdr) {
    this.builder = bdr;
  }
  @Override
  public Media with(String name, String value) {
    return new JsonMedia(
      this.builder.add(name, value)
    );
  }
  public JsonObject json() {
    return this.builder.build();
  }
}
```

Использование:

```java
JsonMedia media = new JsonMedia("book");
media = book.print(media);
JsonObject json = media.json();
```

### 5.4. Private static literals

В главе 2.5. говорилось о том, что использовать public константы очень плохо.

Кратко: public константы создают бессмысленные сязи между разными классами (могут использоваться
в разных контекстах, иметь разный смысл).

Здесь пример почему плохо использовать private static constants. Пример:

```java
class Book {
    private static final String BOOK_NOT_FOUND = "book not found";
    void print() throws Exception {
        if (/* book not found */) {
            throw new Exception(Book.BOOK_NOT_FOUND);
        }
    }
    void sell() throws Exception {
        if (/* book not found */) {
            throw new Exception(Book.BOOK_NOT_FOUND);
        }
    }
}
```

Причины использования private static constants:

1. Замена "магических чисел/слов" на константу. Часто требуется только в больших классах.
В компактных, связных классах, такие константы **излишни**.

2. Введенная константа `BOOK_NOT_FOUND` вроде как избавляет нас от дублирования строк.
Но это ошибочное мнение - внедрение такой константы **маскирует ошибки**.
Рассмотрим примеры ошибок в 5.4.1. и 5.4.2.

#### 5.4.1. Исключения по своей сути разные - требуются разные строки для сообщений

Пример:

```java
class Book {
    void print() throws Exception {
        if (/* book not found */) {     // Одна ошибка
            throw new Exception("book not found, can't print it");
        }
    }
    void sell() throws Exception {
        if (/* book not found */) {     // Совершенно другая ошибка
            throw new Exception("book not found, can't sell it");
        }
    }
}
```

Здесь не требуется статической константы, т.к. по своей сути, исключения отличаются друг от друга.

#### 5.4.2. Ошибки одинаковые - нужно одно место для обработки ошибок

Пример:

```java
class Book {
    void print() throws Exception {
        x = find();
    }
    void sell() throws Exception {
        x = find();
    }
    private X find() throws Exception {
        if (/* book not found */) {
            throw new Exception("book not found");
        }
        return /* книга найдена */;
    }
}
```

Обратный случай: было дублирование проверок `if` - убрали дублирование и сделали проверку в одном
месте. Опять, статическая константа не требуется.

#### 5.4.3. Если все же необходимо использовать private static literals

**Решение #1**. Инжектирование константы через конструктор (можно через вторичный).

```java
class Book {
    private final String notFound;
    Book() {                        // Вторичный конструктор
        this("book not found");
    }
    Book(String msg) {              // Основной конструктор
        this.notFound = msg;
    }
    private X find() throws Exception {
        if (/* book not found */) {
            throw new Exception(this.notFound);
        }
    }
}
```

**Решение #2**. Если не хочется "загрязнять" класс `Book`, то можно создать декоратор,
который ловит исключение и перебрасывает его с нужным сообщением. Более многословно.

```java
class BookNotFoundException extends Exception {
    BookNotFoundException() {
        super();
    }
    BookNotFoundException(Throwable ex, String msg) {
        super(ex, msg);
    }
}

class DefaultBook implements Book {     // "Чистый класс"
    private X find() {                  // Ничего не знает о сообщениях.
        if (/* book not found */) {
            throw new BookNotFoundException();
        }
    }
    public void print() { ... }
    public void sell() { ... }
}

class VerboseBook implements Book {     // "Класс декоратор". Перебрасывает исключения.
    private final Book book;
    private final String msg;
    VerboseBook(Book b) {               // Вторичный конструктор
        this(b, "book not found");
    }
    VerboseBook(Book b, String m) {     // Основной конструктор
        this.book = b;
        this.msg = m;
    }
    @Override
    public void print() {
        try {
            this.book.print();
        } catch (BookNotFoundException ex) {
            throw new BookNotFoundException(ex, this.msg);
        }
    }
    @Override
    public void sell() {
        try {
            this.book.sell();
        } catch (BookNotFoundException ex) {
            throw new BookNotFoundException(ex, this.msg);
        }
    }
}
```

### 5.5. Configurable objects

Примеры конфигурируемых объектов:

№1. Конфигурация объекта через конструктор

```java
class Book {
    Book(String name, boolean verbose) { // verbose - флаг проверки (конфигурация)
        ...
        this.verbose = verbose;
    }
    void sell() {
        ...
        if (this.verbose)
            System.out.println("book sold");
    }
}
```

Или для установки используется объект с несколькими конфигурационными параметрами:

```java
class Book {
    Book(String name, Properties props) { // props - несколько конфигурационных параметров
        ...
        this.props = props;
    }
    ...
```

№2. Конфигурация объекта через *сеттер* (хуже чем 1)

```java
class Book {
    Book(String name) {
        ...
    }
    void setVerbose(boolean verbose) {  // verbose - флаг проверки (конфигурация)
        this.verbose = verbose;
    }
    void sell() {
        ...
        if (this.verbose)
            System.out.println("book sold");
    }
}
```

№3.  Конфигурация объекта через глобальные (системные) переменные (самый плохой вариант)

```java
class Book {
    Book(String name) {
        ...
    }
    void sell() {
        ...
        if (system.getProperty("book.verbose", true))
            System.out.println("book sold");
    }
}
```

**Недостатки** конфигурируемых объектов:

* Объекты с параметрами становятся сложнее

* Введение одного параметра приводит к появлению новых параметров

* Объект становится God object

* Введение параметра может частично раскрыть "внутренности" класса.

#### 5.5.1. Альтернатива (решение) для configurable objects

* Создание новых классов или использование декораторов.

* Введение конфигурационных параметров в класс только в самом крайнем случае

Пример такой структуры:

```java
Book book = new SafeBook(
    new VerboseBook(
        new DefaultBook()
    )
);
```

* `Book` - интерфейс
* `DefaultBook` - реализация интерфейса `Book`. Содержит только базовую логику
* `VerboseBook` - добавление логирования
* `SafeBook` - добавление обработки исключений

Особенности:

* Классы меньшего объема, проще.

* Не всегда декораторы можно использовать в любой последовательности (они содержат логику работы).

### 5.6. Temporal coupling (связь по времени)

* Недостаток наличия temporal coupling (связь по времени) в том, что она снижает поддерживаемость
кода. Чтобы что-то изменить в уже существующем коде - надо его понять: его смысл, алгоритм и т.п.

* Наличие temporal coupling может легко обнаруживаться компилятором, но чаще всего нет.

* Случайно можно изменить порядок строк и получить ошибку (**скрытая temporal coupling**).

**Пример №1.** Временная связь, которая не обнаруживается компилятором:

```java
WriteLn('Hello!');
WriteLn('What is your name?');
```

Если поменять строки местами, компилятор не заметит ошибки, но смысл изменится.

**Решение** для этого примера чтобы избавиться от временной связи - сокращение строки:

```java
WriteLn('Hello!\n' + 'What is your name?');
```

Но чаще всего, в коде такие сокращения сделать невозможно.

**Пример №2.** Числа Фибоначчи

```cpp
int main(int argc, char** argv) {
    int pos = atoi(argv[1]), i = pos, last = 1, prev = 1;
    while (i-- > 2) {
        int temp = last;
        last += prev;
        prev = temp;
    }
    printfn("f(%d) = %d\n", pos, last);
}
```

Смысл поменяется и компилятор не поймает ошибку, если поменять местами, например, строки:

```cpp
int temp = last; --> last += prev;
last += prev;        int temp = last;
```

**Частичное решение**: использование рекурсии:

```java
int fibo(int i) {
    if (i < 3)
        return i;
    return fibo(i - 1) + fibo(i - 2);
}
```

Здесь тоже есть temporal coupling, но компилятор заметит проблему, если поменять порядок строк.

Более **кардинальное решение**. Использование *композиции функций* (здесь не показано).
Но лучше использовать *композицию объектов*, без использования statements (выражения `if`, `<` и т.п.)
(не совсем java код):

```java
class Fibo extends Number {
    Fibo(Number i) {
        super {
            new If(     // If, объект, вычисляется как Lazy
                new LessThan(i, 3),
                i,
                new Fibo(new Difference(i, 1)),
                new Fibo(new Difference(i, 2))
            )
        }
    }
}
```

Использование:

```java
printfn("f(7) = %d", new Fibo(7).intValue())
```

#### 5.6.1. Выводы. Полное избавление от temporal coupling

* Statement'ы (выражения) такие как `if` и `<` приводят к появлению temporal coupling.

* Процедуры способствуют появлению temporal coupling.

* Декларативный (declarative) стиль написания программ приводит к меньшей temporal coupling.

* Длинные методы и методы с несколькими `return` имеют скрытые temporal coupling.

* Существует только один способ избавление от temporal coupling:
любой метод, который имеет более чем один statement (выражение) требует рефакторинга.

* Идеально (но не всегда достижимо), чтобы все методы имели только один statement (выражение)
и этот statement является `return`.

### 5.7. Inheritance

**Общая рекомендация**: отдавайте предпочтение композиции объектов перед наследованием классов.

Есть два вида наследования:

* Subtyping (подтипы)
* Implementation inheritance (наследование реализации)

#### 5.7.1. Subtyping (подтипы) - можно использовать

Пример:

```java
interface Pet {
    String name();
}
interface Lizard extends Pet {
}
class RealLizard imlements Lizard {
    private final String n;
    RealLizard(String name) {
        this.n = name;
    }
    @Override
    public String name() {
        return this.n;
    }
}
```

Наследование здесь используется как реализация интерфейса.
В таком виде наследованием можно пользоваться.

#### 5.7.2. Implementation inheritance (наследование реализации) - использовать нельзя

Пример:

```java
class Iguana extends RealLizard {
    Iguana(String name) {
        super(name);
    }
    String color() {
        return "green";
    }
}
```

Наследование здесь используется как расширение родительского класса.

**Плохо**:

* Такие расширения родительского класса могут копировать, переопределять части родительского класса.

* Получаемый класс является своего рода "Франкенштейном", сшитым из разных кусков кода.

* Переопределяемые части базового класса могут "убиваться" (переопределяться) наследником:
базовый класс в совокупности с дочерним получается "полуживым".

**Вывод**: вместо наследования реализации надо использовать композицию объектов.

### 5.8. Gradients of immutability

Из главы 2.6: объект неизменяем, если состояние объекта не может быть модифицировано после его
создания.

### 5.8.1. Состояние неизменяемости - константа

```java
class Gauge {                       // Какой-то шаблон
    private final Number value;
    Gauge(double v) {
        this(new ZeroToOne(v));
    }
    Gauge(Number v) {
        this.value = v;
    }
    String html() {
        return String.format(this.value.doubleValue() * 100);
    }
}
class ZeroToOne extends Number {    // Валидация
    private final double value;
    ZeroToOne(double v) {
        this.value = v;
    }
    @Override
    public double doubleValue() {
        if (this.value < 0 || this.value > 1) {
            throw new IllegalStateException("Value must be in [0..1] range");
        }
        return this.value;
    }
}
```

Использование:

```java
Gauge gauge1 = new Gauge(0.15);
Gauge gauge2 = new Gauge(0.15);
print gauge1.html();    // Один и тот же результат. Всегда.
print gauge2.html();    // Один и тот же результат. Всегда.
```

Здесь неизменяемые объекты одного класса при одинаковых начальных условиях ведут себя одинаково,
как **константы**.

### 5.8.2. Состояние неизменяемости - не константа

1. Похожий класс, только метод `html()` возвращает значения с небольшим разбросом:

```java
class RandomizedGauge {             // Похож на Gauge
    private final Number value;     // Конструктор опущен.
    String html() {
        return String.format(this.value.doubleValue() * 95 * Math.random());
    }
}
```

Объект класса `RandomizedGauge` все еще **неизменяем**, но уже выдает разные результаты.

2. Похожий класс, только метод `html()` содержит ссылку на файл, откуда берет значение.
Плюс, мы можем сохранять значения в этот же файл:

```java
class GaugeInFile {             // Похож на Gauge
    private final Path path;    // Конструктор опущен.
    String html() {             // Чтение из файла.
        return String.format(
            Double.parseDouble(
                new String(Files.readAllBytes(this.path))));
    }
    void update(double v) {     // Запись в файл.
        Files.write(this.path, Double.toString(v).getBytes());
    }
}
```

Объект класса `GaugeInFile` также **неизменяем**, но т.к. он ссылается на внешний файл, то
прочитанное значение может отличаться (файл может быть изменен/удален). Плюс мы можем
переписать содержимое этого файла.

Чтобы сделать возможным многопоточное использование данного класса, автор предлагает
использовать **thread-safety декоратор** (правда такой декоратор не deadlock-free):

```java
class SyncGauge implements Gauge {
    private final Gauge origin;
    void update(double v) {
        syncronized (this.origin) {
            this.origin.update(v);
        }
    }
    String html() {         // При чтении всегда thread-safety.
        return this.origin.html();
    }
}
```

Использование thread-safety декоратора:

```java
Gauge = new SyncGauge(new GaugeInFile(path));
```

### 5.9. Law of Demeter (Закон Деметры)

Известен как "Закон одной точки". Вот например, так якобы делать нельзя:

```java
class Report {
    void print(Garage garage) {
        int price = garage.getCar("BMW").getPrice();
        System.out.println("price: " + price);
    }
}
```

А вот так якобы делать можно:

```java
class Report {
    void print(Garage garage) {
        int price = garage.getCarPrice("BMW");
        System.out.println("price: " + price);
    }
}
```

В результате объекты типа `garage` содержат сотни методов с именами около 30 символов.

#### 5.9.1. Суть закона Деметры на самом деле

Суть: закон против доступа ко внутренним аттрибутам объекта. Но ничего не имеет против
доступа к другим объектам, которые порождаются этим объектом.

**Плохо**. Для получения года используются геттеры, которые только *возвращаются* объектами:

```java
void print(Garage garage) {
    int year = garage.getCar().getEngine().getModel().getYear();
    System.out.println("year: " + year);
}
```

**Плохо**. Для получения года используются открытые поля класса:

```java
void print(Garage garage) {
    int year = garage.car.engine.model.year;
    System.out.println("year: " + year);
}
```

**Как надо**. Все получаемые значения *создаются* методами-строителями объектов
(правила именования таких методов см. в главе 2.4.1.):

```java
void print(Garage garage) {
    int year = garage.car().engine().model().year();
    System.out.println("year: " + year);
}
```

**Выводы**:

* Мы *не можем* просить машину предоставить нам свой двигатель.

* Но мы *можем* просить машину построить нам новый двигатель.

* Закон Деметры - это *не* "закон одной точки".

* Закон Деметры - это "закон против использования геттеров".

### 5.10. Algorithms

Рассматривается пример игры "Угадай число". В статье рассматриваются примеры реализации
алгоритма этой игры на языках Basic, Pascal, C, Java. По сути, меняется только синтаксис языка,
все остальное остается одинаковым: программа написана процедурно.

Хотя программа, написанная в стиле настоящего ООП, должна выглядеть так (приведен только верхний
уровень):

```java
public class Program {
    public static void main(String... args) {
        Secret secret = new Secret();
        new Farewell(
            new Attempts(
                new VerboseDiff(
                    new Diff(
                        secret,
                        new Guess()
                    )
                ), 5
            ),
            secret
        ).say();
    }
}
```

* Код declarative и объектно-ориентированный.

* Вместо алгоритма здесь используется композиция объектов.

* Каждый объект делает свою работу и имеет единственную ответственность.

* Композиция объектов составляет программу.

## Dark

Глава 6 описывает сущности, действия и т.п. вещи, которые *убивают* ООП. Этого следует избегать
любой ценой:

1) Annotations
2) MVC
3) Dependency Injection Containers
4) Reflection
5) ORM

### 6.1. Annotations

Пример аннотации:

```java
@Important      // Аннотация в Java
class Book {
    private final String title;
    Book(String name) {
        this.title = name;
    }
}
```

**Недостатки** использования аннотаций:

* Аннотации хуже, чем геттеры и сеттеры

* Объект ничего не знает о манипуляциях, которые происходят "благодаря" использованию аннотации

* Объект не может как-то повлиять на действие аннотации

#### 6.1.1. Marshalling (процесс преобразования объекта в какой-либо формат)

Пример Marshalling с использованием аннотаций:

```java
@XmlRootElement
class Car {
    @XmlElement
    public String getModel() {
        return this.model;
    }
    @XmlElement
    public String getMileage() {
        return this.mileage;
    }
}

// Использование - конвертация объекта в документ XML
final JAXBContext ctx = JABContext.newInstance(Car.class);
final Marshaller marshaller = ctx.createMarshaller();
marshaller.marshal(car, System.out);
```

* Marshaller знает о структуре объекта благодаря аннотациям (аннотации указывают на геттеры,
где можно получить информацию из объекта)

* Объект не видит этих манипуляций над ним и не может вмешаться

**Решение** (далеко от совершенства, но все же лучше) - добавление "печати" в XML формат:

```java
class XmlCar {
    private final Car car;
    XmlCar(Car origin) {
        this.car = origin;
    }
    String toXML() {    // Данные "вытигиваются" из объекта
        return "<car><model>" + this.car.getModel() + "</model><mileage>" +
            this.car.getMileage() + "</mileage></car>";
    }
}
// Для печати в JSON
class JsonCar {
    ...
    String toJSON() { ... }
}

// Использование (печать в XML)
car = new XmlCar(new Car());
xml = car.toXML();
```

* Лучше реализовать это решение через "printer" (см. главу 5.3)

* Объект должен руководить Marshaller

* Marshaller не должен "вытягивать" данные из объекта

* Объект должен контролировать все, связанное с его данными

#### 6.1.2. Dependency injection

Пример DI:

```java
class CarRental {
    @Inject
    private Payments payments;
    @Inject
    private Garage garage;
}

// Использование DI контейнера для создания объекта:
rental = container.build(CarRental.class);
```

**Недостатки**:

* Данные в объект должны попадать только через конструктор

* Аннотации поощряют такой вид DI

* (*Притянуто за уши*) Не видно рождения объекта, все создается при помози контейнера

**Решение**:

Вручную создавать все объекты при помощи оператора `new`.

#### 6.1.3. Access control (контроль доступа)

```java
class Car {
    @Roles("admin")
    public String getPrice() { ... }
}

// Использование
car = service.make(Car.class, "Mercedes-Benz SL63");
```

Здесь `service` - объект, который понимает аннотацию `@Roles` и ограничивает доступ к методу
`getPrice()`.

Почему такой подход **ошибочен**:

* Участвует singleton (*? - наверное имеется в виду service*)

* Объект ничего не знает об ограничении доступа

* Для того, чтобы инициализировать объект, мы обращаемя к сервисному слою

* Аннотации статичны, их нельзя менять во время выполнения программы

**Решение** - использование *security decorator*:

```java
car = new SecureCar(
    new Car("Mercedes-Benz SL63"),
    "admin"
);
```

#### 6.1.4. AOP and aspects

Несколько сумбурная глава лично для меня. Приводится примеры использования `AspectJ` framework.

Написано, что AOP "decomposes responsibility vertically".

Потом приводятся примеры, каким был бы `Java`, если бы в нем использовались некоторые дополнительные
конструкции, которые являлись бы функциональной заменой AOP.

### 6.2. MVC

MVC - это скорее не паттерн проектирования, а сочетание трех шагов:

1. получить данные
2. преобразовать данные
3. отобразить данные

Эти три шага должны быть четко отделены друг от друга для улучшения поддерживаемости кода.

**Недостатки** традиционной реализации MVC:

* Horizontal decomposition of responsibility

* Последовательное (процедурное) выполнение шагов

* Контроллер пересылает данные между Model и View

* Появление открытых данных

Пример. Стандартный метод стандартного контроллера MVC (взято из какой-то книги):

```java
class AlbumController {
    public void doGet(HttpServletRequest request, ...) {
        Album album = Album.find(request.getParameter("id"));
        if (album == null) {
            forward("/missingAlbumError.jsp", request, response);
            return;
        }
        request.setAttrbute("helper", album);
        if (album instanceof ClassicalAlbum)
            forward("/classicalAlbum.jsp", request, response);
        else
            forward("/album.jsp", request, response);
    }
}
```

Данные здесь открыты, мы легко можем сделать так и компилятор ничего нам не скажет:

```java
Integer id = request.getParameter("id");
id += 100;      // id открыт и пересылается между объектами
Album album = Album.find(id);
```

Плюс, при добавлении функциональности код будет увеличиваться в размерах. Например, добавили
проверку на `id == null` и проверку на то, что значение закешировано:

```java
Integer id = request.getParameter("id");
if (id == null) {
    throw new Exception("ID is required");
}
Album album;
if (cache.contains(id)) {
    album = cache.get(id);
} else {
    album = Album.find(id);
}
```

**Лучше** сделать так (вертикальное разделение ответственности):

```java
Album album = new CachedAlbum(
    new AlbumOfRequest(
        new NotNullRequest(
            request
        )
    )
);
```

* `request` знает об `id`

* `NotNullRequest` знает как проверять его на `null`

* `AlbumOfRequest` знает как конвертировать `request` в `album`

Еще пример типичного MVC:

```java
class Controller {                                  // Проблема 2
    public String index() {
        String title = new Model().getTitle();      // Проблема 1 и 3
        View view = new View();                     // Проблема 4
        view.setTitle(title);
        return view.renderHTML();
    }
}
```

Список проблем в этом коде:

1. Данные `title` открыты.

2. `Controller` больше походит на utility класс (см. главу 3.2.3) - `Controller` и метод
`index()` не используют локальные поля класса.

3. Model является DTO (см. главу 6.5), что является антипаттерном.

4. View является изменяемым через использование сеттеров (см. главу 3.5), что также
является антипаттерном.

**Решение:**

```java
new View(new Model()).html();
```

* Данные из Model передаются во View через printers (см. главу 5.3). Model "печатает" себя
в некоторую "media", предоставляемую View.

* В *крайнем* случае вместо printers в Model можно использовать геттер, который будет напрямую
передаваться между Model и View.

* Автор в web-приложениях в качестве media использует XML, в качестве rendering инструмента XSL.

**Вывод:**

1. MVC - процедурный паттерн, который не подходит для ООП.

2. Альтернатива - композиция объектов.

### 6.3. Dependency injection containers

О DI упоминалось в главе 3.6.

Наилучший вариант DI - через конструкторы объекта.

Пример использования DI контейнера:

```java
page = container.lookup('Page');
```

**Недостатки использования контейнера**:

* container - синглтон (*прим.: необязательно синглтон*).

* Все объекты должны знать, где находится контейнер, чтобы создавать объекты (*прим.: необязательно*).

* Контейнер связывает приложение целиком, все объекты зависят от него (*прим.: необязательно*).

* Контейнер лишает "удовольствия" ручного создания объекта (см. главу 6.1.2) (*прим.: спорно*).

* Контейнер скрывает структуру программы от программиста.

**Решение:** не пользоваться контейнерами DI, а вручную компоновать объекты.
На вершине программы виден только верхний класс `Application` с единственным методом `run()`,
который содержит в себе более мелкие классы. Пример:

```java
Applicatiob app = new Application(      // Псевдо-приложение заказа пиццы
    new WebFront(
        new Orders(
            new Payments(
                new PayPal("secret-key"),
                new WellsFargo("login")
            )
        )
    ),
    new Kitchen(
        new Queue(),
        new Ovens(
            new Oven("big"),
            new Oven("small")
        )
    )
);
app.run();
```

### 6.4. Reflection

Рефлексия - способность программы изучать, анализировать и модифицировать свою структуру и поведение
во время выполнения.

Любая рефлексия - это **очень плохо**.

#### 6.4.1 - 6.4.2. Type introspection (интроспекция типов, instanceof). Type casting

Пример type introspection:

```java
void print(Manuscript script) {
    if (script instanceof Book) {
        System.out.println(script.contents());      // Печать оглавления
    }
    // Печать остального текста.
}
```

Недостатки:

* Сложность добавления пожжержки новых классов.

* Объекты должны быть ответственны за свое поведение, сторонний класс не должен за них решать,
что им делать.

* Объекты должны выполнять свой контракт (интерфейс) - выполнять ожидаемую от них работу.

Пример type casting:

```java
void print(Manuscript script) {
    System.out.println(
        Book.class.cast(script).contents()      // Печать оглавления
    );
    // Печать остального текста.
}
```

Недостатки:

* Такой кастинг без проверки типа может привести к exception.

* Все недостатки из предыдущего случая.

**Решение** использование полиморфизма:

```java
interface Manuscript {
    void print();
}
class Book implements Manuscript {
    @Override
    public void print() {
        // Печать оглавления
        // Печать остального текста.
    }
}
class Article implements Manuscript {
        @Override
    public void print() {
        // Печать остального текста.
    }
}
```

#### 6.4.3. Annotations

Аннотации не должны использоваться (см. главу 6.1). Использовать рефлексию для манипуляции
с аннотациями также запрещено.

#### 6.4.4 - 6.4.5 . Instatiating by class name. Method invocation by name

Приводится пример чтения названия класса/метода из внешнего источника (XML файла),
а потом с помощью рефлексии создания объекта или вызов метода.

Это категорически запрещено делать - мы должны точно знать имя класса и метода.
Эти имена не должны приходить откуда-то из файлов, сети и т.д.

#### 6.4.6. Setting and getting attributes

#### 6.4.7. Serialization

#### 6.4.8. Byte code manipulations

### 6.5. ORM

#### 6.5.1. Horizontal DoR

#### 6.5.2. Vertical DoR

#### 6.5.3. Mapping engine

#### 6.5.4. DTO

#### 6.5.5. SQL speaking objects

#### 6.5.6. Too many round trips

#### 6.5.7. Duplicated SQL manipulations

#### 6.5.8. "JOIN" and foreign keys

#### 6.5.9. "INSERT"

#### 6.5.10. "UPDATE"

#### 6.5.11. Transactions
