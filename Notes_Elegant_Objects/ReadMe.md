# Элегантные объекты. Vol.1

## Глава 1. Рождение

### 1.1. Не используйте имена, заканчивающиеся на -er и -or. Не используйте Util или Utils тоже

Плохие имена: Util, Utils, Manager, Controller, Helper, Handler, Writer, Reader, Converter, Validator,
Router, Dispatcher, Observer, Listener, Sorter, Encoder и Decoder.

**Хорошие** имена: Target, EncodedText, DecodedData, Content, SortedLines, ValidPage, Source и т. п.
Также хорошо (исключения): Computer или User.

*Пример 1* вариантов имен для Cash:

* Плохо: CashFormatter.
* **Хорошо**: USDCash, CashInUSD.

*Пример 2* список простых чисел:

* Плохо: Primer, PrimeFinder, PrimeChooser, PrimeHelper.
* **Хорошо**: PrimeNumbers.

*Пример 3*:

* Плохо: Listener и Observer.
* **Хорошо**: EventTarget и EventSource.

#### Итого

Когда приходит время давать имя новому классу, думайте о том, что он *есть*, а не о том, что он *делает*.

* Он - список, и он может выбирать элементы из списка по индексу.

* Он - SQL-запись, и он может извлечь отдельную ячейку как целое число.

* Он - пиксел, и он может изменить свой цвет.

* Он - файл, и он может читать содержимое с диска.

* Он - алгоритм кодирования, и он может кодировать.

* Он - HTML-документ, и он может быть отображен.

### 1.2. Сделайте один конструктор главным

1. Конструкторов в классе должно быть больше чем методов: 2-4 метода и 5-10 конструкторов. (+ см. раздел 3.1)

2. Больше конструкторов - больше гибкость, меньше методов - легче использовать класс.

3. Задача конструктора - инициализация свойств.

4. Инициализировать свойства только в одном, основном конструкторе.
Остальные конструкторы должны вызывать основной.

*Пример*:

```java
class Cash {
    private int dollars;
    Cash(float dlr) {
        this((int) dlr)
    }
    Cash(String dlr) {
        this(Cash.parse(dlr));
    }
    Cash(int dlr) {
        this.dollars = dlr;
    }
}
```

5. Основной конструктор помещается в коде после вторичных конструкторов.

6. Т.о. установка полей и возможная проверка может быть сосредоточена только
в одном месте.

### 1.3. В конструкторах не должно быть кода

1. Конструктор объекта не должен содержать код и затрагивать аргументы.

2. Инстанцирование объекта не делает ничего, кроме его сборки.

3. Реальная работа выполняется методами объекта.

*Пример 1*. Плохо:

```java
class Cash {
    private int dollars;
    Cash(String dlr) {
        this.dollars = Integer.parseInt(dir);
    }
}
```

+ Разбор числа выполняется только при создании объекта.

- Долгая инициализация.

- Неуправляемая работа - разбор происходит всегда, оптимизировать не получится.

*Пример 2*. **Хорошо**:

```java
class Cash {
    private Number dollars;
    Cash(String dlr) {      // вторичный
        this(new StringAsInteger(dlr));
    }
    Cash(Number dlr) {      // основной
        this.dollars = dlr;
    }
    int intValue() {
        return this.dollars.intValue();
    }
}
class StringAsInteger implements Number {
    private String source;
    StringAsInteger(String src) {
        this.source = src;
    }
    int intValue() {
        return Integer.parseInt(this.source);
    }
}

// Использование
Cash five = new Cash("5");      // только создается, разбора нет.
five.intValue();                // первый разбор
five.intValue();                // второй разбор
```

+ Быстрая инициализация.

+ Отложенный управляемый разбор хранимого значения. По требованию.

- Разбор строки при каждом вызове intValue().

*Решение* для последнего минуса - декоратор, выполняющий кэширование
результата:

```java
class CachedNumber implements Number {
    private Number origin;
    private Collection<Integer> cached = ArrayList<>(1);  // чтобы избежать возврата null
    public CachedNumber(Number num) {
        this.origin = num;
    }
    public int intValue() {
        if (this.cached.isEmpty()) {
            this.cached.add(this.origin.intValue());
        }
        return this.cached.get(0);
    }
}

// Использование
Number num = new CachedNumber(
    new Cash("123")
);
num.intValue();     // первый разбор строки
num.intValue();     // здесь разбора не происходит
```

*Пример 3*. Пример качественно спроектированного ПО:

```java
App app = new App(new Data(), new Screen());    // Только инициализация, без работы
app.run();                                      // Начало выполнения работы.
```

## Глава 2. Образование

### 2.1. Инкапсулируйте как можно меньше

1. Инкапсулировать не более **четырех** объектов.

2. Если нужно инкапсулировать больше объектов - класс требует рефаторинга
(разбить класс не меньшие, часть объектов включить в дополнительный класс).

3. Рекомендация (для Java) всегда переопределять метод `equals()` и избегать
оператора `==`.

### 2.2. Инкапсулируйте хотя бы что-нибудь

1. Всегда надо что-то инкапсулировать. Иначе похоже на статический метод (фу-фу).

*Пример 1*. Плохо. Класс, не инкапсулирует ничего:

```java
class Year {
    int read() {
        return System.currentTimeMillis()
            / (1000 * 60 * 60 * 24 * 30 * 12) - 1970;
    }
}
```

*Пример 2*. **Хорошо**:

```java
class Year {
    private Millis millis;
    Year(Millis msec) {
        this.millis = msec;
    }
    int read() {
        return this.millis.read()
            / (1000 * 60 * 60 * 24 * 30 * 12) - 1970;
    }
}
```

### 2.3. Всегда используйте интерфейсы

1. Использование интерфейсов - лучший инструмент для улучшения сопровождаемости.

2. Это возможность модификации объекта, не модифицируя связанные с ним объекты.

3. Все публичные методы должны реализовывать какой-либо интерфейс.

*Пример*. Использование интерфейса:

```java
interface Cash {
    Cash multiply(float factor);
}
class DefaultCash implements Cash {
    private int dollars;
    DefaultCash(int dlr) {
        this.dollars = dlr;
    }
    @Override
    Cash multiply(float factor) {
        return new DefaultCash(this.dollars * factor);
    }
}
class Employee {
    private Cash salary;
}
```

### 2.4. Тщательно выбирайте имена методов

1. Не используйте геттеры и сеттеры (см. раздел 3.5).

#### 2.4.1. Строители - это существительные (или прилагательное + существительное)

*Строитель* - метод, который конструирует и всегда возвращает объект. Они никогда
не возвращают `void`.

*Пример 1*. Плохо: название метода глагол, который указывает объекту, что ему делать. Надо сообщить объекту, что должно быть построено.

```java
InputStream load(URL url);
String read(File file);
int add(int x, int y);
```

*Пример 2*. **Хорошо**. Надо так:

```java
InputStream stream(URL url);
String content(File file);
int sum(int x, int y);
```

*Пример 3*. **Хорошо**:

```java
int pow(int base, int power);
float speed();
Employee employee(int id);
String parsedCell(int x, int y);    // прилагательное + существительное
```

#### Не рекомендуется использовать паттерн "Строитель"

*Пример* паттерна:

```java
class Book {
    Book withAuthor(String author);
    Book withTitle(String title);       // сокращение от bookWithTitle
    Book withPage(Page page);
}
```

1. Не рекомендуется использовать паттерн "Строитель", т.к. он способствует созданию
крупных объектов, которые сложны в поддержке и намного более слабее связаны, чем
компактные.

2. Вместо использования паттерна "Строитель", стоит разбить сложные объекты
на несколько простых.

#### 2.4.2. Манипуляторы - это глаголы (или наречие + глагол)

*Манипулятор* - метод, который изменяет сущность реального мира, абстагируемую
объектом. Всегда возвращают `void`.

*Пример 1*.

```java
class Pixel {
    void paint(Color color);    // метод-манипулятор, не возвращает результата
}

// Использование
Pixel center = new Pixel(50, 50);
center.paint(new Color("red"));
```

*Примеры*:

```java
void save(String content);
void put(String key, Float value);
void remove(Employee emp);
void quicklyPrint(int id);      // наречие + глагол
```

#### Избавление от методов строителей-манипуляторов

Не должно быть методов, которые одновременно строят и манипулируют.

*Пример 1*. Плохо:

```java
// 1. возвращает количество сохраненных байтов
int save(String content);

// 2. возвращает true, если ассоциативный массив был изменен
boolean put(String key, Float value);

// 3. изменяет скорость и возвращает ее предыдущую величину
float speed(float val);
```

*Пример 2*. **Хорошо** (переделанные предыдущие методы):

// Исправленный 1 метод.

```java
void save(String content);
// или
int bytesSaved(String content);
```

// Исправленный 2 метод. Вводится класс `PutOperation`:

```java
class PutOperation {
    private string key;
    private float value;
    private boolean success;

    PutOperation(String key, Float value) {
        this.key = key;
        this.value = value;
    }
    void save() {
        // сохраняет (используются this.key и this.value)
        // выполняется операция, устанавливается this.success
    }
    boolean success() {
        return this.success;
    }
}

// Использование. put переименовывается в putOperation
PutOperation putOperation(String key, Float value);
```

// Исправленный 3 метод. Вводится класс `SaveSpeed`:

```java
class SaveSpeed {
    private float newValue;
    ...
    SaveSpeed(float value) {
        this.newValue = value;
    }
    void save() {
        // сохраняет значение скорости
    }
    float previousSpeed() {
        // возвращает предыдущее значение скорости
    }
}
```

*Пример 3*. Плохо:

```java
class Document {
    int write(InputStream content);     // и строитель и манипулятор
}
```

**Хорошо** (переделка):

```java
class Document {
    OutPipe output();
}
class OutputPipe {
    void write(InputStream content);    // манипулятор
    int bytes();                        // строитель
    long time();                        // строитель
}
```

#### 2.4.3. Методы, возвращающие логические значения - это прилагательные

1. Методы, возвращающие логические значения - это строители. Для лучшей
читаемости их имена надо делать прилагательными.

2. Префикс *is* избыточен и не должен использоваться явно.

*Примеры*:

```java
boolean empty();        // is empty
boolean readable();     // is readable
boolean negative();     // is negative

boolean equalTo(Object obj);    // Вместо equals(Object obj);
boolean present();              // Вместо exists();
```

### 2.5. Не используйте публичные константы (и enum тоже)

Ипользование публичных констант:

**+** Решает проблему дублирования кода

#### 2.5.1. Привнесение сцепления

**-** Где применяется константа? Как и на что повлияет изменение ее значения?

#### 2.5.2. Потеря цельности

**-** Константа "не знает" о своей миссии, о своем назначении.

#### Решение

1. Объекты не должны совместно использовать данные.

2. Вместо константы надо создавать новые классы.

**+** Сцепление посредством контракта (классы можно разъединить).

**+** Можно изменить поведение "константы-класса", не меняя его интерфейс.

*Пример 1*.

```java
// Перевод константы в класс
class EOLString {
    private final String origin;
    EOLString(String src) {
        this.origin = src;
    }
    @Override
    String toString() {
        return String.format("%s\r\n", origin);
    }
}

// Использование
class Records {
    void write(Writer out) {
        for (Record rec : this.all) {
            out.write(new EOLString(rec.toString()));
        }
    }
}
```

*Пример 2*. Плохо:

```java
String body = new HttpRequest()
    .method(Http.Methods.POST)  // Статический строковый литерал "POST"
    .fetch();
```

**Хорошо**:

```java
String body = new PostRequest(new HttpRequest())
    .fetch();
```

### 2.6. Делайте классы неизменяемыми

Неизменяемость делает классы:

* Небольшими
* Цельными
* Рацепленными
* Хорошо сопровождаемыми

*Пример 1.* Неизменяемый класс.

```java
class Cash {
    private final int dollars;      // Инициализация только в конструкторе
    Cash(int val) {
        this.dollars = val;
    }
    public Cash mul(int factor) {
        return new Cash(this.dollars * factor);     // Новый объект
    }
}

// Использование
Cash five = new Cash(5);
Cash fifty = five.mul(10);
```

#### Решаемые проблемы, если объект неизменяем

* Изменяемость идентичности.

* Атомарность отказов. Либо полный и целостный объект, либо отказ. Никаких
промежуточных состояний.

```java
class Cash {
    private final int dollars;
    private final int cents;
    public Cash mul(int factor) {
        if (/* что-то не так */) {
            throw new RuntimeException("ой...");
        }
        return new Cash(
            this.dollars * factor,
            this.cents * factor
        );
    }
}
```

* Временное сцепление. Инициализация объекта и его инстанцирование
происходят в один момент времени.

```java
Cash price = new Cash();
price.setDollars(29);
System.out.println(price);  // "$29.00"!
price.setCents(95);
```

* Отсутствие побочных эффектов.

* Никаких нулевых (NULL) ссылок.

Плохо:

```java
class User {
    private final int id;
    // В неизменяемом объекте, такого поля не будет
    private String name = null;
    public User(int num) {
        this.id = num;
    }
    public void setName(String txt) {
        this.name = txt;
    }
}
```

* Потокобезопасность.

* Объекты поменьше и попроще.
  * Типичный (рекомендуемый) размер - не более **250 строк**.
  * Сопровождаемость.
  * Тяжело сделать неизменяемый объект слишком большим.

### 2.7. Пишите тесты, а не документацию

1. Пишите простой легко читаемый код.

2. Простой код говорит сам за себя и не требует дополнительной документации.

3. Плохие классы вынуждают писать для них документацию.

4. Не документируйте код, а делайте его чище.

5. Юнит-тест и есть документация. Он показывает как использовать класс.

6. Уделяйте юнит-тестам такое же внимание, как и основному коду.

### 2.8. Используйте fake-объекты вместо mock-объектов

1. Мокинг - плохая практика.

2. Мокинг превращает предположения в факты. Мы должны знать, что вызовет
тестируемый класс у подстановочного mock класса, чтобы сделать замещение
у нужного метода.

3. Мокинг привязывает тесты к внутренним деталям реализации класса.

4. Вместо мокинга задействовать fake-объекты. Причем, fake-объект должен
поставляться вместе с интерфейсом.

*Пример*. (Не самый удачный, но суть видно):

```java
interface Exchange {
    float rate(String origin, String target);
    final class Fake implements Exchange {
        @Override
        float rate(String origin, String target) {
            return 1.2345;
        }
    }
}

// Использование
Exchange exchange = new Exchange.Fake();
Cash dollar = new Cash(exchange, 500);
Cash euro = dollar.in("EUR");
assert "6.17".equals(euro.toString());
```

5. Работая с интерфейсом и создавая для него fake-класс, вы неизбежно
вынуждены думать как пользователь интерфейса, а не только как его
разработчик.

#### Рекомендации по созданию fake-классов

* Оснастить свои интерфейсы fake-классами.

* Убедиться, что все классы не имеют методов, не реализующих интерфейс
(см. раздел 2.3).

### 2.9. Делайте интерфейсы краткими, используйте smart-классы

1. Важно делать интерфейсы небольшими.

2. Вместо расширения интерйфейса используйте smart-класс внутри него.

3. Функционал smart-класса может быть совместно использован несколькими
классами.

4. Smart-класс может содержать очень большое количество методов.

5. Smart-классы неидеальные объекты. Они являются инструментами,
помогающими создавать хорошие объекты.

*Пример*. Избыточный интерфейс:

```java
interface Exchange {
    float rate(String target);
    float rate(String source, String target);
}
```

*Решение*. Использовать smart-класс внутри интерфейса.

```java
interface Exchange {
    float rate(String source, String target);

    final class Smart {
        private final Exchange origin;
        public float toUsd(String source) {
            return this.origin.rate(source, "USD");
        }
        public float eurToUsd() {
            return this.toUsd("EUR");
        }
    }
}

// Использование
float rate = new Exchange.Smart(new NYSE()).toUsd("EUR");
float rate = new Exchange.Smart(new NYSE()).eurToUsd();
```

## Глава 3. Работа

### 3.1. Предоставляйте менее пяти публичных (и защищенных) методов

1. Из раздела 1.2: конструкторов в классе должно быть больше чем методов:
2-4 метода и 5-10 конструкторов.

2. Из раздела 2.6: класс должен быть менее чем 250 строк.

3. Здесь добавляется еще ограничение - не более 5 публичных/защищенных
методов.

Достоинства малых по размеру классов.

* Более элегантны. (Меньше вероятность сделать ошибку).

* Лучше сопровождаются

* Более цельные.

* Более верифицируемы.

### 3.2. Не используйте статические методы

Статические методы - это хуже, чем наличие константы NULL.

Статические методы ухудшают сопровождаемость программного обеспечения.

*Пример*. Без статики можно реализовать "ленивое" вычисление (статика сразу вычисляет):

```java
class Between implements Number {
  private final Number num;
  Between(Number left, Number right, Number x) {
      this.num = new Min(new Max(left, x), right);
  }
  @Override
  public int intValue() {
      return this.num.intValue();
  }
}

// Использование:
Number y = new Between(5, 9, 13);    // еще не вычисляется!
```

#### 3.2.1. Классы-утилиты

Т.н. классы-утилиты на самом деле являются не классами, а лишь набором статических методов,
используемых другими классами для удобства (они известны также как методы-помощники).

Классы-утилиты - ужасный антипаттерн в ООП.

* Мы не можем собирать крупные объекты из более мелких с применением  статических методов.
*(Прим.: Кстати, почему?)*

* Не используйте в коде ключевое слово `static`.

#### 3.2.2. Паттерн «Синглтон»

Отличие синглтона от класса-утилиты: синглтон - это зависимость, которую можно разорвать,
а класс-утилита - жестко запрограммированная тесная связь, которую разорвать невозможно.

Иными словами, преимущество синглтонов в том, что в них можно добавить метод `setInstance()`
наряду с `getInstance()`.

*Итого:*

* «Синглтон» - ужасный антипаттерн.

* Чем заменить синглтон, если класс требуется во многих местах?
Ответ: инкапсуляция. Все, что нужно вашему классу для работы, должно быть передано посредством
конструктора и инкапсулировано внутри класса.

#### 3.2.3. Функциональное программирование (ФП)

*Примечание: какая-то невнятная глава.*

Преимущества ООП над ФП:

* ООП более выразительно.

* ООП оперирует объектами и методами, ФП - лишь функциями.

Идеальный ООП: классы с функциями внутри (которые имеют единственную точку выхода,
как в функциональной парадигме).

#### 3.2.4. Компонуемые декораторы

**Компонуемые декораторы** - объекты-обертки над другими объектами. Они становятся *компонуемыми*,
когда мы объединяем их в многослойные структуры.

*Пример*.

```java
names = new Sorted(
    new Unique(
        new Capitalized(
            new Replaced(
                new FileNames(
                    new Directory(
                        "/var/users/*.xml"
                    )
                ),
                "([^.]+)\\.xml",
                "$1"
            )
        )
    )
);
```

Все эти классы - компонуемые декораторы.

**Принципы компоновки**:

* Классы могут реализовывать тот же интерфейс, что и инкапсулированные объекты (но это необязательно).

* Каждый компонуемый декоратор добавляет некоторое поведение инкапсулированным объектам.

* Код должен состоять из такой "пирамиды" объектов.

* Не должно быть процедурных операторов вроде `if`, `for`, `switch` и `while`.

*Еще пример*. Превращение процедурного кода в объектно-ориентированный:

```java
// процедурный код
float rate;
if (client.age() > 65) {
    rate = 2.5;
}
else {
    rate = 3.0;
}

// он же, но объектно-ориентированный
float rate = new If(
    new GreaterThan(
        new AgeOf(client),
        65
    ),
    2.5, 3.0
);
```

### 3.3. Не допускайте аргументов со значением NULL

#### Обертка объекта для его передачи в метод без использования NULL

*Пример*. Плохо.

```java
public Iterable<File> find(String mask) {
    if (mask == null) {         // Дурной тон
        // найти все файлы
    } else {
        // найти файлы по маске
    }
}
```

*Пример*. Лучше.

```java
public Iterable<File> find(Mask mask) {
    if (mask.empty()) {
        // найти все файлы
    } else {
        // найти файлы по маске
    }
}
```

*Пример*. **Хорошо**.

```java
public Iterable<File> find(Mask mask) {
    Collection<File> files = new LinkedList<>();
    for (File file : /* все файлы */) {
        if (mask.matches(file)) {
            files.add(file);
        }
    }
    return files;
}
```

#### Передача в метод нулевого объекта

```java
interface Mask {
    boolean matches(File file);
}

// Нулевой объект
class AnyFile implements Mask {
    @Override
    boolean matches(File file) {
        return true;
    }
}
```

#### Если в метод все же передается NULL. Две стратегии поведения

* **Оборонительная стратегия**. Проверка аргумента на NULL и выброс исключения.

```java
public Iterable<File> find(Mask mask) {
    if (mask == null) {
        throw new IllegalArgumentException("Маска не может быть NULL");
    }
    // Найти файлы по маске и вернуть результат.
}
```

* **Стратегия игнорирования**. Рекомендуется. Рано или поздно будет
выброшено исключение `NullPointerException`.

### 3.4. Будьте лояльным и неизменяемым либо константным

У каждого объекта есть три элемента:

1. Идентичность - что отличает данный объект от других объектов.

2. Состояние - что объект знает о том, что он хранит (например, файл на диске).

3. Поведение - что объект может сделать по запросу.

* Константный объект:
  * Имеет **неизменяемое состояние**.
  * Может иметь неуникальную идентичность (может не отличаться от других объектов (например, переопределение `equals`))
  * Может иметь изменяемое поведение (например, файл на диске изменился - теперь читаются другие данные).

* Лучше использовать константные объекты, т.к. они проще для проектирования, поддержки и понимания.

### 3.5. Никогда не используйте геттеры и сеттеры

1. Хороший класс не позволяет получать доступ к своим полям.
Он черный ящик.

2. Геттеры и сеттеры нарушают принцип инкапсуляции.

3. Префикс `get` вреден (см. раздел 2.4).

4. С точки зрения пользователя, геттеры и сеттеры представляют данные, а не поведение.

5. Геттеры и сеттеры - ужасный антипаттерн ООП.

#### Объекты против структур данных

Пример структуры данных - DTO.

* Структура данных - мешок с данными, класс - не дает прямого доступа к своим полям.

* Структуры данных прозрачны, объекты - нет.

* Структуры данных склоняют к применению процедурного стиля программирования.

### 3.6. Не используйте оператор new вне вторичных конструкторов

Не используйте оператор new внутри основного конструктора.

*Пример 1*. Плохо.

```java
class Cash {
    private final int dollars;
    public int euro() {
        return new Exchange().rate("USD", "EUR") * this.dollars;
    }
}
```

Что плохо: нельзя разорвать связь между классами Cash и Exchange.

Решение:

1. Объекты могут принимать новые объекты только в качестве аргументов
конструктора и инкапсулировать в приватных полях.

2. Не используйте оператор `new` нигде, кроме вторичных конструкторов.
Благодаря этому объекты будут полностью расцеплены.

3. Оператор `new` нельзя использовать даже внутри основного конструктора.

*Пример 1*. **Хорошо**:

```java
class Cash {
    private final int dollars;
    private final Exchange exchange;
    Cash() {                            // вторичный конструктор
        this(0);
    }
    Cash(int value) {                   // вторичный конструктор
        this(value, new NYSE());
    }
    Cash(int value, Exchange exch) {    // основной конструктор
        this.dollars = value;
        this.exchange = exch;
    }
    public int euro() {
        return this.exchange.rate("USD", "EUR") * this.dollars;
    }
}
```

*Пример 2*. Плохо. Код, который должен инстанцировать объекты.

```java
class Requests {
    private final Socket socket;
    public Requests(Socket skt) {
        this.socket = skt;
    }
    public Request next() {
        return new SimpleRequest(           // использование new!
            // Прочесть данные из сокета
        )
    }
}
```

*Пример 2*. **Хорошо**.

```java
class Requests {
    private final Socket socket;
    private final Mapping<String, Request> mapping;
    public Requests(Socket skt) {
        this(
        skt,
        new Mapping<String, Request>() {
            @Override
            public Request map(String data) {
                return new SimpleRequest(data);
            }
        });
    }
    public Requests(Socket skt, Mapping<String, Request> mpg) {
        this.socket = skt;
        this.mapping = mpg;
    }
    public Request next() {
        return this.mapping.map(
            // Прочесть данные из сокета
        );
    }
}
```

### 3.7. Избегайте интроспекции (рефлексии) и приведения типов

1. Рефлексия - хороший инструмент для плохих программистов.

2. Приведение типов - по сути принуждение объекта подчиниться контракту,
по выполнение которого он не подписывался.

## Глава 4. Уход на пенсию

### 4.1. Никогда не возвращайте NULL

1. Причины возврата NULL - подход "как можно безопаснее".
Возвращение NULL - прием выживания.

#### 4.1.1. Альтернативы NULL (3 подхода)

1. Отказывать как можно скорее (подход скорейшего отказа)

  * Остановить выполнение и выбросить исключение, как только мы столкнемся с проблемой (любой!)

  * Такой подход в итоге повышает качество всего приложения в целом.

2. Если что-то не найдено - возврат пустой коллекции.

*Пример 1*. Плохо.

```java
public User user(String name) {
    if (/* имя не найдено в базе данных */) {
        return null;
    }
    return /* запись из базы данных */;
}
```

*Пример 1*. **Хорошо**.

```java
public Collection<User> users(String name) {
    if (/* имя не найдено в базе данных */) {
        return new ArrayList<>(0);
    }
    return Collections.singleton(
        /* из базы данных */
    );
}
```

3. Паттерн "пустой объект".

Когда искомый объект не найден, возвращается объект, похожий на настоящий,
но ведущий себя по-другому (он может делать что-то одно, но не делать
что-то другое).

*Пример*:

```java
class NullUser implements User {
    private final String label;
    NullUser(string name) {
        this.label = name;
    }
    @Override
    public String name() {
        return this.label;
    }
    @Override
    public void raise(Cash salary) {
        throw new IllegalStateException("Пользователь-заглушка");
    }
}
```

4. **Не рекомендуется**. Применение generic-класса `java.util.Optional`.

Похож на коллецию, но содержит 1 элемент. Это решение противоречит
принципам ООП и не рекомендуется использовать его, т.к. оно семантически
некорректно.

Метод называется `user()`, но возвращает "конверт" с пользователем, что сбивает с толку и
не соответствует духу ООП.

### 4.2. Бросайте только проверяемые исключения

Для проверяемых исключений компилятор заранее проверяет код на их
наличие. Если он их найдет, то не скомпилирует код, пока мы не обработаем исключения или не пробросим их наверх.

1. Непроверяемые исключения - недостаток языка, все исключения должны
быть проверяемыми.

2. Проверяемые исключения всегда на виду.

3. Если метод может кинуть непроверяемое исключение, то очень
большая вероятность, что исключение будет неверно обработано.

#### 4.2.1. Не ловите исключения без необходимости

1. Не ловите исключения без особой необходимости, делайте это, только
если у вас нет другого выбора.

2. Идеальное приложение - на каждую точку входа есть единственный блок
`catch`.

3. Использовать быстрый отказ. Не прятать проблему, а пробрасывать
исключение наверх.

4. Исключения не для замены условных операторов. Они должны обозначать
критическую ситуацию, не допускающую восстановления.
В результате возникновения которой прекращается нормальное исполнение
программы и нужно принимать чрезвычайные меры.

5. Поимка исключения и спасение ситуации - действия, которые должны
иметь под собой серьезную причину. Это подход безопасного отказа.

6. Ловить и записывать в журнал - **ужасный антипаттерн**.

#### 4.2.2. Стройте цепочки исключений

1. Пойманное исключение оборачивается в новое и пробрасывается выше.

2. После нескольких раз, всплывшее исключение будет содержать в себе
много слоев из внутренних исключений.

3. Самый верхний catch сможет достать все "обернутые" исключения,
благодаря чему легко можно отследить источник проблемы.

4. В идеале каждый метод должен ловить все возможные исключения и
перебрасывать их, формируя цепочки исключений.

*Пример*:

```java
public int length(File file) throws Exception {
    try {
        return content(file).length();
    } catch (IOException ex) {
        throw new Exception("Невозможно определить размер файла.", ex);
    }
}
```

#### 4.2.3. Восстанавливайтесь единожды и только на верхнем уровне

1. Всем методам должно быть разрешено перебрасывать исключения, не обрабатывая
их (см. предыдущий раздел).

2. Все исключения всплывают:

  * на верхний уровень приложения.

  * к точкам входа в приложение.

  * к точкам, через которые пользователь общается с приложением.

3. На верхнем уровне исключения обрабатываются (ничего не перебрасывается).

4. Количество таких "законных" мест для восстановления в приложении обычно
невелико.

#### 4.2.4. Используйте аспектно-ориентированное программирование

*Пример*. Плохо. Повтор загрузки веб-страницы посредством HTTP-запроса:

```java
public String content() throws IOException {
    int attempt = 0;
    while (true) {
        try {
            return http();
        } catch (IOException ex) {
            if (attempt >= 2) {
                throw ex;
            }
        }
    }
}
```

Данный пример противоречит предыдущему разделу.

Есть только одно решение - *аспектно-ориентированное программирование* (АОП).

*Пример*. **Хорошо**. Тоже, но с использованием АОП:

```java
@RetryOnFailure(attemts = 3)        // повторить при ошибке (макс. 3 раза)
public String content() throws IOException {
    return http();
}
```

*Ссылка* с информацией по АОП: http://aspects.jcabi.com

#### 4.2.5. Достаточно одного типа исключений

1. Типизация исключений избыточна из-за (из предыдущих разделов):

  * восстанавливаемся лишь единожды

  * объект исключения содержит вложенные исключения

  * исключения ловятся с целью их пробрасывания выше

  * информация о типе исключения не нужна, т.к. она нигде не используется

### 4.3. Классы либо константные (нельзя от них наследовать), либо абстрактные

1. Наследование делает отношения между объектами слишком запутанными.
(Методы одного класса могут быть вызваны из разных иерархий классов).

2. Рекомендуется использовать классы:

  * константные (от них нельзя наследовать, методы не переопределяются)

  * абстрактные (переопределяются некоторые методы, остальные методы константные)

*Пример*. Что использовать вместо наследования.

Вместо наследования - определяется интерфейс и создаются требуемые классы.

```java
interface Document {
    int length();
    byte[] content();
}

final class DefaultDocument implements Document {    // константный класс
    @Override
    public int legth() { /*...*/ }
    @Override
    public byte[] content() { /*...*/ }
}

final class EncryptedDocument implements Document {
    private final Document plain;       // вместо наследования
    EncryptedDocument(Document doc) {
        this.plain = doc;
    }
    @Override
    public int length() {
        return this.plain.length();
    }
    @Override
    public byte[] content() {
        byte[] raw = this.plain.content();
        /* Дополнительный функционал по расшифровки содержимого */
    }
}
```

3. Рекомендуется помечать классы с помощью ключевых слов *final* или *abstract*.

4. Наследование использовать только для абстрактного класса, когда требуется
**уточнить** поведение класса (а не изменить его).

*Пример*. Уточнение поведения:

```java
abstact class Document {
    public abstract byte[] content();
    public final int length() {
        return this.content().length;
    }

final class DefaultDocument extends Document {
    @Override
    public byte[] content {                 // уточнения поведения 1
        // Загружает содержимое с диска
    }
}

final class EncryptedDocument extends Document {
    @Override
    public byte[] content() {               // уточнение поведения 2
        // Загружает содержимое с диска,
        // расшифровывает и возвращает его
    }
}
```

### 4.4. Используйте принцип RAII

1. RAII (Resource Acquisition Is Initialization) - принцип:
"выделение ресурсов есть инициализация".

2. По сути, это вызов `dispose()`, `close()` и других подобных методов на
объектах, которые уже не нужны.

3. В C++ эту задачу выполняют деструкторы, в Java - интерфейс `AutoCloseable`.

*Пример*.

```java
int main() {
    try (Text t = new Text("/tmp/test.txt")) {
        t.content();
    }
}
```

# Элегантные объекты. Vol.2

## Gray

### 5.1. Compound names (Составные имена)

### 5.2. Validators and assertions (Валидаторы и утверждения)

### 5.3. Printers instead of getters

#### 5.3.1. Single Responsibility Principle

#### 5.3.2. God object

#### 5.3.3. Code duplication

#### 5.3.4. Utility objects

#### 5.3.5. Polymorphic media

### 5.4. Private static literals

### 5.5. Configurable objects

### 5.6. Temporal coupling

### 5.7. Inheritance

#### 5.7.1. Subtyping

#### 5.7.2. Implementation inheritance

### 5.8. Gradients of immutability

### 5.9. Law of Demeter

### 5.10. Algorithms

## Dark

### 6.1. Annotations

#### 6.1.1. Marshalling

#### 6.1.2. Dependency injection

#### 6.1.3. Access control

#### 6.1.4. AOP and aspects

### 6.2. MVC

### 6.3. Dependency injection containers

### 6.4. Reflection

#### 6.4.1. Type introspection

#### 6.4.2. Type casting

#### 6.4.3. Annotations

#### 6.4.4. Instatiating by class name

#### 6.4.5. Method invocation by name

#### 6.4.6. Setting and getting attributes

#### 6.4.7. Serialization

#### 6.4.8. Byte code manipulations

### 6.5. ORM

#### 6.5.1. Horizontal DoR

#### 6.5.2. Vertical DoR

#### 6.5.3. Mapping engine

#### 6.5.4. DTO

#### 6.5.5. SQL speaking objects

#### 6.5.6. Too many round trips

#### 6.5.7. Duplicated SQL manipulations

#### 6.5.8. "JOIN" and foreign keys

#### 6.5.9. "INSERT"

#### 6.5.10. "UPDATE"

#### 6.5.11. Transactions
