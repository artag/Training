# 5. Microservice collaboration (взаимодействие)

- Understanding how microservices collaborate through commands, queries, and events.
(Понимание того, как микросервисы взаимодействуют с помощью команд, запросов и событий)

- Comparing event-based collaboration with collaboration based on commands and queries.
(Сравнение совместной работы на основе событий с совместной работой, основанной на командах и запросах)

- Implementing an event feed.
(Реализация потока событий)

- Implementing command-, query-, and event-based collaboration.
(Реализация совместной работы на основе команд, запросов и событий)

- Deploying collaborating microservices to Kubernetes.
(Развертывание взаимодействующих микросервисов в Kubernetes)

Микросервисы могут использовать три основных способа взаимодействия для совместной работы:
команды (commands), запросы (queries) и события (events). Каждый из этиъ способов имеет свои
сильные и слабые стороны, и понимание компромиссов между ними позволит выбрать подходящий.

## 5.1 Types of collaboration: Commands, queries, and events

(Типы взаимодействий: команды, запросы и события)

В качестве примера рассмотрим микросервис программы лояльности POS-системы из
главы 4. Микросервис программы лояльности прост: в ней регистрируются клиенты; после
регистрации они получают уведомления о новых специальных предложениях
и зарабатывают баллы лояльности, когда они что-то покупают.
На рис. 5.1 показано, что микросервис программы лояльности должен
сотрудничать с рядом других микросервисов:

![The loyalty program microservice collaborates with several other microservices.](images/22_collaboration.jpg)

Существует три способа взаимодействия между двумя микросервисами:

- *Commands* - команды используются, когда одному микросервису требуется другой микросервис
для выполнения действия. Например, микросервис программы лояльности отправляет команду
микросервису уведомлений, когда ему требуется отправить уведомление зарегистрированному
пользователю.

- *Queries* - запросы используются, когда одному микросервису требуется информация от
другого микросервиса. Например, клиенты с большим количеством баллов лояльности получают
скидку: микросервис выставления счетов запрашивает у микросервиса программы лояльности
количество баллов лояльности, имеющихся у пользователя.

- *Events* - события используются, когда микросервису необходимо отреагировать на что-то,
что произошло в другом микросервисе. Например, микросервис программы лояльности привязан
к событиям микросервиса специальных предложений: при появлении нового специального
предложения он может отправлять уведомления зарегистрированным пользователям.

Два микросервиса могут взаимодействовать между собой одним, двумя или всеми тремя
способами. На рис. 5.2 снова показаны варианты взаимодействия в рамках микросервиса
программы лояльности:

![The loyalty program microservice uses all three collaboration styles.](images/23_collaboration_styles.jpg)

Взаимодействие, основанное на командах и запросах, должно использовать относительно
детализированные команды и запросы.
Вызовы между микросервисами являются удаленными вызовами, что означает, что они пересекают
границу процесса, часто используя сеть. Это означает, что вызовы между микросервисами
выполняются относительно медленно.

**Следует предпочесть способ взаимодействия, основанный на событиях**.
Взаимодействие на основе событий более слабо связано, чем два других способа, т.к. события
обрабатываются асинхронно. Это означает, что два микросервиса, взаимодействующих
посредством событий, не связаны во времени; обработка события не обязательно должна
происходить сразу после его появления. Скорее всего, обработка может произойти, когда
подписчик готов это сделать. Напротив, команды и запросы являются синхронными и поэтому
должны обрабатываться сразу после их отправки.

### 5.1.1 Commands and queries: Synchronous collaboration

(Команды и запросы: cинхронное взаимодействие)

Команды (commands) и запросы (queries) - это синхронные формы взаимодействий.
Оба реализуются как HTTP-запросы от одного микросервиса к другому. Запросы
реализуются с помощью HTTP `GET`-запросов, тогда как команды реализуются с помощью HTTP
запросов `POST`, `PUT` или `DELETE`.

>Команды и запросы через gRPC
>
>gRPC является сильным кандидатом в качестве альтернативы использованию HTTP.
>gRPC - это протокол для выполнения удаленных вызовов процедур (RPC).
>Команды - это вызовы методов, которые выполняют действие в вызываемом микросервисе,
>а запросы - это методы, которые возвращают некоторую информацию от вызываемого
>микросервиса.
>
>Работа с gRPC начинается с определения контракта в виде `proto` файла, в котором
>описаны процедурные вызовы. Файл `proto` используется для генерации кода как на стороне >клиента, так и на стороне сервера. Этот функционал в nuget пакете `Grpc.Tools`.
>
>Достоинства gRPC:
>
>- *Эффективность*. gRPC использует `HTTP/2` и `protobuf`. `Protobuf` - гораздо более
>компактный формат, чем JSON. `HTTP/2` обеспечивает бОльшую эффективность, чем `HTTP/1`.
>
>- *Явные контракты* (explicit contracts). Файлы `proto` определяют контракт между
>микросервисами. Библиотеки gRPC проверяют контракт во время выполнения.
>Это палка о двух концах: мы можем добиться некоторой безопасности, сделав контракты явными,
>но мы также теряем некоторую гибкость в развитии микросервисов.
>
>- *Хорошая поддержка .NET*. Nuget пакет `Grpc.Tools` используется для генерации кода
>из файлов `proto`. Nuget пакет `Grpc.AspNetCore` используется для hosting endpoints
>в ASP.NET.

Микросервис программы лояльности может отвечать на запросы о зарегистрированных
пользователях и может обрабатывать команды для создания или обновления зарегистрированных
пользователей. На рис. 5.3 показано взаимодействие на основе команд и запросов:

![Collaboration with three microservices using commands and queries.](images/24_commands_queries.jpg)

Рис. 5.3 включает два разных запроса (query):

- "Получить баллы лояльности для зарегистрированного пользователя"
- "Получить настройки для зарегистрированного пользователя".

Эти два запроса можно обработать при помощи одного endpoint, который возвращает
представление (representation) зарегистрированного пользователя. Представление включает в себя как
количество баллов лояльности, так и настройки.
Один endpoint делается по двум причинам:

- Проще сделать и обслуживать один endpoint, чем два.
- Понятнее, т.к. микросервис программы лояльности получает одно общее представление
зарегистрированного пользователя вместо того, чтобы придумывать специализированные форматы
для специализированных запросов.

На рисунке 5.3 в микросервис программы лояльности отправляются две команды (command):

- регистрация нового пользователя (HTTP `POST`)
- обновление существующего зарегистрированного пользователя (HTTP `PUT`)

`POST` часто используется для создания нового ресурса, а `PUT` для обновления ресурса.

В целом, микросервис программы лояльности должен предоставлять три конечных точки:

- Endpoint HTTP `GET` по URL `/users/{userId}`.
  - Возвращает представление пользователя.
  - Реализует оба запроса (query) - см. рис. 5.3.

- Endpoint HTTP `POST` по URL `/users/`.
  - Входной параметр - представление пользователя (в теле запроса).
  - Регистрирует этого пользователя в программе лояльности.

- Endpoint HTTP `PUT` по URL `/users/{userId}`
  - Входной параметр - представление пользователя (в теле запроса).
  - Обновляет уже зарегистрированного пользователя.

На рисунке 5.4 показан микросервис программы лояльности. Endpoints реализованы в компоненте
HTTP API.

![The endpoints exposed by the loyalty program microservice](images/25_loyalty_endpoints.jpg)

Другие микросервисы, которые взаимодействуют с микросервисом программы лояльности
похожи по структуре и содержат компонент `LoyaltyProgramClient`.
Например, структура микросервиса выставления счетов может быть такой (рис. 5.5):

![The invoice microservice](images/26_loyalty_client.jpg)

Представление зарегистрированного пользователя `LoyaltyProgramUser`,
которое программа лояльности ожидает получить в командах и с помощью которого она будет отвечать
на запросы:

```csharp
public record LoyaltyProgramUser(
    int Id, string Name, int LoyaltyPoints, LoyaltyProgramSettings Settings);

public record LoyaltyProgramSettings()
{
    public LoyaltyProgramSettings(string[] interests) : this()
    {
        this.Interests = interests;
    }

    public string[] Interests { get; init; } = Array.Empty<string>();
}
```

Определения endpoints и двух классов формируют контракт взаимодействия с микросервисом программы
лояльности. Данный контракт использует компонент `LoyaltyProgramClient`, см. рис. 5.6:

![The invoice microservice calls the loyalty program microservice](images/27_invoice_calls.jpg)
