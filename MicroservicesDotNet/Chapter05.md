# 5. Microservice collaboration (взаимодействие)

- Understanding how microservices collaborate through commands, queries, and events.
(Понимание того, как микросервисы взаимодействуют с помощью команд, запросов и событий)

- Comparing event-based collaboration with collaboration based on commands and queries.
(Сравнение совместной работы на основе событий с совместной работой, основанной на командах и запросах)

- Implementing an event feed.
(Реализация потока событий)

- Implementing command-, query-, and event-based collaboration.
(Реализация совместной работы на основе команд, запросов и событий)

- Deploying collaborating microservices to Kubernetes.
(Развертывание взаимодействующих микросервисов в Kubernetes)

Микросервисы могут использовать три основных способа взаимодействия для совместной работы:
команды (commands), запросы (queries) и события (events). Каждый из этиъ способов имеет свои
сильные и слабые стороны, и понимание компромиссов между ними позволит выбрать подходящий.

## 5.1 Types of collaboration: Commands, queries, and events

(Типы взаимодействий: команды, запросы и события)

В качестве примера рассмотрим микросервис программы лояльности POS-системы из
главы 4. Микросервис программы лояльности прост: в ней регистрируются клиенты; после
регистрации они получают уведомления о новых специальных предложениях
и зарабатывают баллы лояльности, когда они что-то покупают.
На рис. 5.1 показано, что микросервис программы лояльности должен
сотрудничать с рядом других микросервисов:

![The loyalty program microservice collaborates with several other microservices.](images/22_collaboration.jpg)

Существует три способа взаимодействия между двумя микросервисами:

- *Commands* - команды используются, когда одному микросервису требуется другой микросервис
для выполнения действия. Например, микросервис программы лояльности отправляет команду
микросервису уведомлений, когда ему требуется отправить уведомление зарегистрированному
пользователю.

- *Queries* - запросы используются, когда одному микросервису требуется информация от
другого микросервиса. Например, клиенты с большим количеством баллов лояльности получают
скидку: микросервис выставления счетов запрашивает у микросервиса программы лояльности
количество баллов лояльности, имеющихся у пользователя.

- *Events* - события используются, когда микросервису необходимо отреагировать на что-то,
что произошло в другом микросервисе. Например, микросервис программы лояльности привязан
к событиям микросервиса специальных предложений: при появлении нового специального
предложения он может отправлять уведомления зарегистрированным пользователям.

Два микросервиса могут взаимодействовать между собой одним, двумя или всеми тремя
способами. На рис. 5.2 снова показаны варианты взаимодействия в рамках микросервиса
программы лояльности:

![The loyalty program microservice uses all three collaboration styles.](images/23_collaboration_styles.jpg)

Взаимодействие, основанное на командах и запросах, должно использовать относительно
детализированные команды и запросы.
Вызовы между микросервисами являются удаленными вызовами, что означает, что они пересекают
границу процесса, часто используя сеть. Это означает, что вызовы между микросервисами
выполняются относительно медленно.

**Следует предпочесть способ взаимодействия, основанный на событиях**.
Взаимодействие на основе событий более слабо связано, чем два других способа, т.к. события
обрабатываются асинхронно. Это означает, что два микросервиса, взаимодействующих
посредством событий, не связаны во времени; обработка события не обязательно должна
происходить сразу после его появления. Скорее всего, обработка может произойти, когда
подписчик готов это сделать. Напротив, команды и запросы являются синхронными и поэтому
должны обрабатываться сразу после их отправки.

### 5.1.1 Commands and queries: Synchronous collaboration

(Команды и запросы: cинхронное взаимодействие)

Команды (commands) и запросы (queries) - это синхронные формы взаимодействий.
Оба реализуются как HTTP-запросы от одного микросервиса к другому. Запросы
реализуются с помощью HTTP `GET`-запросов, тогда как команды реализуются с помощью HTTP
запросов `POST`, `PUT` или `DELETE`.

>Команды и запросы через gRPC
>
>gRPC является сильным кандидатом в качестве альтернативы использованию HTTP.
>gRPC - это протокол для выполнения удаленных вызовов процедур (RPC).
>Команды - это вызовы методов, которые выполняют действие в вызываемом микросервисе,
>а запросы - это методы, которые возвращают некоторую информацию от вызываемого
>микросервиса.
>
>Работа с gRPC начинается с определения контракта в виде `proto` файла, в котором
>описаны процедурные вызовы. Файл `proto` используется для генерации кода как на стороне >клиента, так и на стороне сервера. Этот функционал в nuget пакете `Grpc.Tools`.
>
>Достоинства gRPC:
>
>- *Эффективность*. gRPC использует `HTTP/2` и `protobuf`. `Protobuf` - гораздо более
>компактный формат, чем JSON. `HTTP/2` обеспечивает бОльшую эффективность, чем `HTTP/1`.
>
>- *Явные контракты* (explicit contracts). Файлы `proto` определяют контракт между
>микросервисами. Библиотеки gRPC проверяют контракт во время выполнения.
>Это палка о двух концах: мы можем добиться некоторой безопасности, сделав контракты явными,
>но мы также теряем некоторую гибкость в развитии микросервисов.
>
>- *Хорошая поддержка .NET*. Nuget пакет `Grpc.Tools` используется для генерации кода
>из файлов `proto`. Nuget пакет `Grpc.AspNetCore` используется для hosting endpoints
>в ASP.NET.

Микросервис программы лояльности может отвечать на запросы о зарегистрированных
пользователях и может обрабатывать команды для создания или обновления зарегистрированных
пользователей. На рис. 5.3 показано взаимодействие на основе команд и запросов:

![Collaboration with three microservices using commands and queries.](images/24_commands_queries.jpg)

Рис. 5.3 включает два разных запроса (query):

- "Получить баллы лояльности для зарегистрированного пользователя"
- "Получить настройки для зарегистрированного пользователя".

Эти два запроса можно обработать при помощи одного endpoint, который возвращает
представление (representation) зарегистрированного пользователя. Представление включает в себя как
количество баллов лояльности, так и настройки.
Один endpoint делается по двум причинам:

- Проще сделать и обслуживать один endpoint, чем два.
- Понятнее, т.к. микросервис программы лояльности получает одно общее представление
зарегистрированного пользователя вместо того, чтобы придумывать специализированные форматы
для специализированных запросов.

На рисунке 5.3 в микросервис программы лояльности отправляются две команды (command):

- регистрация нового пользователя (HTTP `POST`)
- обновление существующего зарегистрированного пользователя (HTTP `PUT`)

`POST` часто используется для создания нового ресурса, а `PUT` для обновления ресурса.

В целом, микросервис программы лояльности должен предоставлять три конечных точки:

- Endpoint HTTP `GET` по URL `/users/{userId}`.
  - Возвращает представление пользователя.
  - Реализует оба запроса (query) - см. рис. 5.3.

- Endpoint HTTP `POST` по URL `/users/`.
  - Входной параметр - представление пользователя (в теле запроса).
  - Регистрирует этого пользователя в программе лояльности.

- Endpoint HTTP `PUT` по URL `/users/{userId}`
  - Входной параметр - представление пользователя (в теле запроса).
  - Обновляет уже зарегистрированного пользователя.

На рисунке 5.4 показан микросервис программы лояльности. Endpoints реализованы в компоненте
HTTP API.

![The endpoints exposed by the loyalty program microservice](images/25_loyalty_endpoints.jpg)

Другие микросервисы, которые взаимодействуют с микросервисом программы лояльности
похожи по структуре и содержат компонент `LoyaltyProgramClient`.
Например, структура микросервиса выставления счетов может быть такой (рис. 5.5):

![The invoice microservice](images/26_loyalty_client.jpg)

Представление зарегистрированного пользователя `LoyaltyProgramUser`,
которое программа лояльности ожидает получить в командах и с помощью которого она будет отвечать
на запросы:

```csharp
public record LoyaltyProgramUser(
    int Id, string Name, int LoyaltyPoints, LoyaltyProgramSettings Settings);

public record LoyaltyProgramSettings()
{
    public LoyaltyProgramSettings(string[] interests) : this()
    {
        this.Interests = interests;
    }

    public string[] Interests { get; init; } = Array.Empty<string>();
}
```

Определения endpoints и двух классов формируют контракт взаимодействия с микросервисом программы
лояльности. Данный контракт использует компонент `LoyaltyProgramClient`, см. рис. 5.6:

![The invoice microservice calls the loyalty program microservice](images/27_invoice_calls.jpg)

### 5.1.2 Events: Asynchronous collaboration. События: асинхронное взаимодействие

Взаимодействия, основанные на событиях, являются асинхронными. То есть микросервис, который
публикует события, не вызывает микросервисы, которые подписываются на события.
Подписчики обрабатывают новые события, когда они готовы их обработать. Когда мы используем
HTTP для реализации этого вида взаимодействия подписчики проводят опрос о новых событиях.
Этот опрос - это то, что автор называет подпиской на ленту событий. Хотя опросы это синхронные
запросы, взаимодействие является асинхронным, поскольку публикация событий не зависит от
опросов подписчиков на предмет новых событий.

![Subscribe to events](images/28_subscribe_to_events.jpg)

На рис. 5.7 изображен микросервис программы лояльности, подписанный на события микросервиса
специальных предложений. Последний может публиковать события всякий раз, когда что-то
происходит в его домене. Например, когда новое специальное предложение становится активным.
Публикация события в данном контексте означает сохранение события в
хранилище данных специальных предложений. Программа лояльности не увидит событие до тех пор,
пока не обратится к ленте событий со специальными предложениями. Когда это произойдет, полностью
зависит от программы лояльности. Это может произойти сразу после публикации события или в любой
другой более поздний момент времени.

### Exposing an event feed. Отображение ленты событий

Микросервис может публиковать события для других микросервисов через канал событий, который
является просто HTTP endpoint. Например `/events`. На этот endpoint другой микросервис может
отправлять запросы, из которых он может получать данные о событиях.
На рис. 5.8 показаны компоненты микросервиса специальных предложений,
выделены компоненты, участвующие в реализации ленты событий:

![Special offers microservice](images/29_special_offers.jpg)

События, опубликованные микросервисом специальных предложений, хранятся в его базе данных.Компонент `EventStore` содержит код, который считывает и записывает события в эту базу данных.
Код модели домена может использовать `EventStore` для хранения событий, которые ему необходимо
опубликовать. Компонент `Event Feed` - это реализация HTTP endpoint `/events`, которая
предоставляет события другим микросервисам.

Компонент `Event Feed` использует `EventStore` для чтения событий из базы данных, а
затем возвращает события в теле HTTP-ответа. Подписчики могут использовать
параметры запроса для управления: какие события и какое их количество будет передано.

### Subscribing to events. Подписка на события

Подписка на ленту событий по сути означает, что вы проводите опрос endpoint событий
микросервиса, на который вы подписаны. Периодически вы отправляете HTTP-запрос `GET` на
endpoint `/events`, чтобы проверить, есть ли какие-либо события, которые вы еще не обработали.

На рис. 5.9 представлен общий вид микросервиса программы лояльности, состоящий из двух процессов:

![Loyalty program microservice](images/30_event_subscriber.jpg)

The event-subscriber process - это фоновый процесс, который периодически отправляет запросы
в ленту событий микросервиса специальных предложений для получения новых событий.
Когда он получает обратно пакет новых событий, он обрабатывает их, отправляя команды в
микросервис уведомлений для уведомления зарегистрированных пользователей о новых специальных
предложениях.

- `Special Offers Subscriber` - компонент, где реализован опрос ленты событий
- `Notifications-Client` - компонент, отвечает для отправки команды уведомлений.

Частота опросов на новые события может сильно отличаться в зависимости от конкретного варианта
использования. Часто события извлекаются каждые 30 секунд или каждые несколько минут.
Бывает опросы с частотой в 1 секунду или каждый час.

>### Events over queues
>
>Альтернативой публикации событий через ленту событий является использование технологии очередей,
>такой как `RabbitMQ`, `AWS SQS` или `Azure Queue Storage`. При таком подходе микросервисы,
>публикующие события, помещают их в очередь, а подписчики считывают их оттуда.
>События должны быть перенаправлены от издателя нескольким подписчикам.
>Микросервис, подписывшийся на события, сожержит процесс подписки на события, который считывает
>события из очереди и обрабатывает их. Повтор событий также может быть реализован с
>использованием очередей, но может потребовать небольших доработок - зависит от выбранной
>технологии.
>
>Это жизнеспособный способ взаимодействий между микросервисами. Но в книге используется
>взаимодействие на основе ленты/канала событий по HTTP, т.к.:
>
>- Это позволяет воспроизводить события в любое время
>- Это простое и надежное масштабируемое решение.
>
>### Event over gRPC
>
>gRPC имеет концепцию потоковой передачи, которая поддерживает открытое соединение HTTP/2 и
>отправляет данные через это соединение.
>Потоковая передача в gRPC работает в обоих направлениях - от клиента к серверу или от сервера
>к клиенту. Для моделирования событий с использованием потоковой передачи gRPC можно создать
>удаленную процедуру, которая работает примерно так же, как лента событий: она позволяет
>подписчикам событий вызывать процедуру и получать события в потоке ответов.

### 5.1.3 Data formats. (Форматы данных)

Обмен данными в формате JSON хорошо работает во многих ситуациях.
В зависимости от задач иногда лучше использовать что-то другое:

- Если требуется обмен большим объемами данных, может потребоваться более компактный формат.
Текстовые форматы, такие как JSON и XML, намного более многословны, чем двоичные
форматы, такие как protocol buffers.
- Если нужен более структурированный (structured) формат, чем JSON, который все еще удобочитаем
для человека, то можно использовать YAML.
- Если ваша компания использует проприетарный формат данных, то вам может потребоваться
поддержка этого формата.

Во всех этих случаях нужны endpoints, способные получать и посылать данные в отличном от JSON
формате. Например, запрос на регистрацию пользователя в микросервисе программы лояльности с
использованием YAML в теле запроса выглядит так:

```yaml
# (1) - Asks for the response in YAML format
# (2) - Specifies that the request body is in YAML format
# (3) - Provides a YAML-formatted request body

POST /users HTTP/1.1
Host: localhost:5000
Accept: application/yaml          # (1)
Content-Type: application/yaml    # (2)

Name: Christian     # (3)
Settings:
  Interests:
    - whisky
    - cycling
    - "software design"
```

В ответе на этот запрос также используется YAML:

```yaml
# (1) - Specifies that the response body is in YAML format
# (2) - Provides a YAML-formatted response body

HTTP/1.1 201 Created
Content-Type: application/yaml            # (1)
Location: http://localhost:5000/users/1

Id: 1               # (2)
Name: Christian
Settings:
  Interests:
    - whisky
    - cycling
    - "software design"
```

## 5.2 Implementing collaboration. (Реализация взаимодействия)

Реализация взаимодействия будет состоять из трех шагов:

1. Создание проекта для loyalty program (программы лояльности). Как раньше: создание
пустого приложения ASP.NET и добавление ASP.NET MVC.

2. Реализация взаимодействий на основе команд и запросов. Реализация всех команд и запросов,
в микросервисах которые их используют.

3. Реализация взаимодействий на основе событий. Сначала реализация event feed (ленты событий)
в разделе "Специальные предложения", а затем реализация подписки в программе лояльности.
Подписка будет включена в новый проект программы лояльности и будет управляться
Kubernetes CronJob.

Микросервис loyalty program состоит из веб-процесса (web process) и event consumer process, который
реализует взаимодействие на основе событий:

![Loyalty program microservice](images/31_lp_microservice.jpg)

### 5.2.1 Setting up a project for the loyalty program

Создание проекта web process для loyalty program так же, как было описано во 2 главе:

```text
dotnet new web -n LoyaltyProgram
```

Реализация `Program.cs` похожа на реализацию в главе 2.
См. [LoyaltyProgram/Program.cs](chapter05/LoyaltyProgram/LoyaltyProgram/Program.cs)

### 5.2.2 Implementing commands and queries

Для web process в loyalty program надо реализовать следующие endpoints:

- `GET` по адресу `/users/{userId}`, который возвращает информацию о пользователе.
- `POST` по адресу `/users/`, который принимает информацию о пользователе и регистрирует его
в сервисе loyalty program.
- `PUT` по адресу `/users/{userId}`, который принимает информацию о пользователе и обновляет
информацию о зарегистрированном пользователе.

### 5.2.3 и 5.2.4 Implementing commands with HTTP `POST`, `PUT` and `GET`

Контроллер можно посмотреть тут:
[LoyaltyProgram/Users/UsersController.cs](chapter05/LoyaltyProgram/LoyaltyProgram/Users/UsersController.cs)

Информация о пользователе тут:
[LoyaltyProgram/Users/LoyaltyProgramUser.cs](chapter05/LoyaltyProgram/LoyaltyProgram/Users/LoyaltyProgramUser.cs). В книге этого кода нет.

```csharp
public record LoyaltyProgramUser(int Id, string Name, int LoyaltyPoints, LoyaltyProgramSettings Settings);

public record LoyaltyProgramSettings()
{
    public LoyaltyProgramSettings(string[] interests) : this()
    {
        Interests = interests;
    }

    public string[] Interests { get; init; } = Array.Empty<string>();
}
```

Это приемная сторона. Клиентская часть, API Gateway microservice:

![API Gateway microservice](images/23_collaboration_styles.jpg)

это mock, консольное приложение. Его код в книге не показан. Находится тут:
[chapter05/ApiGatewayMock](chapter05/ApiGatewayMock/).

Интерес представляет класс [ApiGatewayMock/LoyaltyProgramClient.cs](chapter05/ApiGatewayMock/LoyaltyProgramClient.cs):

```csharp
public class LoyaltyProgramClient
{
    private readonly HttpClient _httpClient;

    public LoyaltyProgramClient(HttpClient httpClient)
    {
        _httpClient = httpClient;
    }

    // (1) Sends the command to loyalty program
    public Task<HttpResponseMessage> RegisterUser(string name)
    {
        var user = new { name, Settings = new { } };
        return _httpClient.PostAsync("/users/", CreateBody(user));      // (1)
    }

    // (1) Sends the UpdateUser command as a PUT request
    public Task<HttpResponseMessage> UpdateUser(LoyaltyProgramUser user) =>
        _httpClient.PutAsync($"/users/{user.Id}", CreateBody(user));    // (1)

    public Task<HttpResponseMessage> QueryUser(string arg) =>
        _httpClient.GetAsync($"/users/{int.Parse(arg)}");

    // (1) Serializes user as JSON
    // (2) Sets the Content-Type header
    private static StringContent CreateBody(object user) =>
        new StringContent(                      // (1)
            JsonSerializer.Serialize(user),
            Encoding.UTF8,
            "application/json");                // (2)
}
```

Он создает запросы к loyalty program microservice и получает ответы в виде `HttpResponseMessage`.

### 5.2.5 Implementing an event-based collaboration
