# Module 7. Asynchronous Programming (Async/Await)

## Lesson 43. Overview

* Typical .NET calls are blocking
  * `int n = foo(); bar(n);` - пример. Вызов `foo` заблокирует вызвавший его поток.
  * Why should `foo()` block the current thread? (e.g., UI thread)
  * Why not run `foo()` in a separate thread and let `bar()` be a continuation?
* Can spawn (создать) a thread to do `foo()` in
  * E.g., `ThreadPool.QueueUserWorkItem` or `Task.Factory.StartNew`
  * We can do `bar()` in a `ContinueWith()` call
  * Too cumbersome (слишком громоздко), we want to use "ordinary" programming model
  * Want to be able to call methods synchronously *or* asynchronously
* .NET already has a "resumable" (возобновляемую) paradigm
  * `yield` allows temporary suspension of execution (позволяет временно приостановить исполнение)
  * Repurposed (перепрофилированный) for asynchronous use (PowerThreading `AsyncEnumerator`)
* .NET `async` and `await` keywords make it official

О чем вкратце речь: вызов метода `foo()` заблокирует выполнение потока. Поток будет ждать окончания
выполнения этого метода и только потом вызовет следующий метод `bar()`. Чтобы ускорить работу
и не блокировать текущий поток (например UI), мы можем запустить выполение `foo()` в другом потоке
и назначить `bar()` как continuation.

Но это слишком громоздко и сложно. Хочется работать как с обычным синхронным кодом.

.NET уже имеет похожий механизм `yield`, который позволяет временно приостановить выполнение
какой-либо операции. Плюс за основу была взята библиотека(?) PowerThreading `AsyncEnumerator`.
Так официально в .NET появился механизм async/await.

### How does `async` work?

Suppose you have a method

```csharp
int Calculate();
```

To make it asynchronous, we redefine it as

```csharp
Task<int> CalculateAsync();
```

Internally, `Calculate` and `CalculateAsync` are the same: they can both return 123.

Now, the consuming method can be rewritten as

```csharp
async void Foo()
{
    int n = await CalculateAsync();
}
```

### What does `async` do?

Not much, actually. The `async` keyword does not change code generated by the compiler.
Think of it as a compiler hint. This hint enables the use of `await` keyword.

`async` keyword informs the compiler that, when it sees `await`, it's a special keyword.

Why is this necessary? Because `await` wasn't a reserved word since the beginning of C#.

### What does `await` do?

Quite a lot!

* Does not perform a physical wait (blocking)

```csharp
int foo = await CalculateAsync();
```

is not the same as

```csharp
int foo = CalculateAsync().Result;
```

Последнее выражение: this would block the caller - precisely what we want to avoid!

* Notice there is no explicit unwrapping (нет явной распаковки).

`await` coerces (разворачивает) the return value from a `Task`.

* And you complete in the same synchronization context, making the whole thing UI-safe!

### What `await` turns into

What you wrote:

```csharp
int n = awaitCalculateAsync();
tbFoo.Text = n.ToString();
```

What you end up with (approximate!):

```csharp
CalculateAsync()        // a task
    .Start()
    .ContinueWith(
        t => tbFoo.Text = t.Result.ToString(),
        TaskScheduler.FromCurrentSynchronizationContext());
```

`FromCurrentSynchronizationContext` позволяет обновить поле `tbFoo.Text` из первоначального потока,
из которого был запущен `CalculateAsync`. Иначе, если не указать, то continuation может быть
запущена из другого thread, что приведет к exception: нельзя обновлять элементы UI из другого
потока.

### What does `await` do (recap)?

* Registers continuation with the async operation.

In other words, "code that follows me is a continuaton, like `ContinueWith()`".

* Gives up the current thread.

It's over. We no longer do anything on the current thread.
(Все закончено. Мы больше ничего не делаем в текущем потоке.)

* The call happens on a thread from the TPL thread pool.

* Проверяет, if `SynchronizationContext.Current != null`, ensures the continuation is also posted
there (e.g., on the UI thread).

If `SynchronizationContext.Current == null`, continuation scheduled using current task scheduler.

This behavior can be customized right on the call.

* Coerces (можно перевести как "достает") the result of the asynchronous operation.

## Lesson 44. Using Async and Await

Блокировка при нажатии на кнопку в WinForms приложении. Во время "вычисления" значения
в течении 5 секунд приложение становится неотзывчивым. После возврата значения "вычисления"
основной UI поток изменяет text лейбла `LblResult` на форме.

```csharp
public int CalculateValue()
{
    Thread.Sleep(5000);
    return 123;
}

private void BtnCalculate_Click(object sender, EventArgs e)
{
    var n = CalculateValue();
    LblResult.Text = n.ToString();
}
```

Этот же пример, только "вычисление" производится в отдельном `Task` и используется
`TaskContinuation` в основном потоке. В это случае блокировки приложения не происходит.

```csharp
public Task<int> CalculateValueAsync()
{
    return Task.Factory.StartNew(() =>
    {
        Thread.Sleep(5000);
        return 123;
    });
}

private void BtnCalculate_Click(object sender, EventArgs e)
{
    var calculation = CalculateValueAsync();
    calculation.ContinueWith(t =>
    {
        LblResult.Text = t.Result.ToString();
    },
    TaskScheduler.FromCurrentSynchronizationContext());
}
```

Теперь, тоже самое, но с использованием `await`:

```csharp
public async Task<int> CalculateValueAsync()
{
    await Task.Delay(5000);
    return 123;
}

private async void BtnCalculate_Click(object sender, EventArgs e)
{
    int value = await CalculateValueAsync();
    LblResult.Text = value.ToString();
}
```

Еще пример. Используется `await` с WebClient:

```csharp
public async Task<int> CalculateValueAsync()
{
    await Task.Delay(5000);
    return 123;
}

private async void BtnCalculate_Click(object sender, EventArgs e)
{
    int value = await CalculateValueAsync();
    LblResult.Text = value.ToString();

    await Task.Delay(5000);

    using (var wc = new WebClient())
    {
        var data = await wc.DownloadStringTaskAsync("http://google.com/robots.txt");
        // Берется первая строка из полученного string
        LblResult.Text = data.Split('\n')[0].Trim();
    }
}
```
