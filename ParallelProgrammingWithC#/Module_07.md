# Module 7. Asynchronous Programming (Async/Await)

## Lesson 43. Overview

* Typical .NET calls are blocking
  * `int n = foo(); bar(n);` - пример. Вызов `foo` заблокирует вызвавший его поток.
  * Why should `foo()` block the current thread? (e.g., UI thread)
  * Why not run `foo()` in a separate thread and let `bar()` be a continuation?
* Can spawn (создать) a thread to do `foo()` in
  * E.g., `ThreadPool.QueueUserWorkItem` or `Task.Factory.StartNew`
  * We can do `bar()` in a `ContinueWith()` call
  * Too cumbersome (слишком громоздко), we want to use "ordinary" programming model
  * Want to be able to call methods synchronously *or* asynchronously
* .NET already has a "resumable" (возобновляемую) paradigm
  * `yield` allows temporary suspension of execution (позволяет временно приостановить исполнение)
  * Repurposed (перепрофилированный) for asynchronous use (PowerThreading `AsyncEnumerator`)
* .NET `async` and `await` keywords make it official

О чем вкратце речь: вызов метода `foo()` заблокирует выполнение потока. Поток будет ждать окончания
выполнения этого метода и только потом вызовет следующий метод `bar()`. Чтобы ускорить работу
и не блокировать текущий поток (например UI), мы можем запустить выполение `foo()` в другом потоке
и назначить `bar()` как continuation.

Но это слишком громоздко и сложно. Хочется работать как с обычным синхронным кодом.

.NET уже имеет похожий механизм `yield`, который позволяет временно приостановить выполнение
какой-либо операции. Плюс за основу была взята библиотека(?) PowerThreading `AsyncEnumerator`.
Так официально в .NET появился механизм async/await.

### How does `async` work?

Suppose you have a method

```csharp
int Calculate();
```

To make it asynchronous, we redefine it as

```csharp
Task<int> CalculateAsync();
```

Internally, `Calculate` and `CalculateAsync` are the same: they can both return 123.

Now, the consuming method can be rewritten as

```csharp
async void Foo()
{
    int n = await CalculateAsync();
}
```

### What does `async` do?

Not much, actually. The `async` keyword does not change code generated by the compiler.
Think of it as a compiler hint. This hint enables the use of `await` keyword.

`async` keyword informs the compiler that, when it sees `await`, it's a special keyword.

Why is this necessary? Because `await` wasn't a reserved word since the beginning of C#.

### What does `await` do?

Quite a lot!

* Does not perform a physical wait (blocking)

```csharp
int foo = await CalculateAsync();
```

is not the same as

```csharp
int foo = CalculateAsync().Result;
```

Последнее выражение: this would block the caller - precisely what we want to avoid!

* Notice there is no explicit unwrapping (нет явной распаковки).

`await` coerces (разворачивает) the return value from a `Task`.

* And you complete in the same synchronization context, making the whole thing UI-safe!

### What `await` turns into

What you wrote:

```csharp
int n = awaitCalculateAsync();
tbFoo.Text = n.ToString();
```

What you end up with (approximate!):

```csharp
CalculateAsync()        // a task
    .Start()
    .ContinueWith(
        t => tbFoo.Text = t.Result.ToString(),
        TaskScheduler.FromCurrentSynchronizationContext());
```

`FromCurrentSynchronizationContext` позволяет обновить поле `tbFoo.Text` из первоначального потока,
из которого был запущен `CalculateAsync`. Иначе, если не указать, то continuation может быть
запущена из другого thread, что приведет к exception: нельзя обновлять элементы UI из другого
потока.

### What does `await` do (recap)?

* Registers continuation with the async operation.

In other words, "code that follows me is a continuaton, like `ContinueWith()`".

* Gives up the current thread.

It's over. We no longer do anything on the current thread.
(Все закончено. Мы больше ничего не делаем в текущем потоке.)

* The call happens on a thread from the TPL thread pool.

* Проверяет, if `SynchronizationContext.Current != null`, ensures the continuation is also posted
there (e.g., on the UI thread).

If `SynchronizationContext.Current == null`, continuation scheduled using current task scheduler.

This behavior can be customized right on the call.

* Coerces (можно перевести как "достает") the result of the asynchronous operation.

## Lesson 44. Using Async and Await

Блокировка при нажатии на кнопку в WinForms приложении. Во время "вычисления" значения
в течении 5 секунд приложение становится неотзывчивым. После возврата значения "вычисления"
основной UI поток изменяет text лейбла `LblResult` на форме.

```csharp
public int CalculateValue()
{
    Thread.Sleep(5000);
    return 123;
}

private void BtnCalculate_Click(object sender, EventArgs e)
{
    var n = CalculateValue();
    LblResult.Text = n.ToString();
}
```

Этот же пример, только "вычисление" производится в отдельном `Task` и используется
`TaskContinuation` в основном потоке. В это случае блокировки приложения не происходит.

```csharp
public Task<int> CalculateValueAsync()
{
    return Task.Factory.StartNew(() =>
    {
        Thread.Sleep(5000);
        return 123;
    });
}

private void BtnCalculate_Click(object sender, EventArgs e)
{
    var calculation = CalculateValueAsync();
    calculation.ContinueWith(t =>
    {
        LblResult.Text = t.Result.ToString();
    },
    TaskScheduler.FromCurrentSynchronizationContext());
}
```

Теперь, тоже самое, но с использованием `await`:

```csharp
public async Task<int> CalculateValueAsync()
{
    await Task.Delay(5000);
    return 123;
}

private async void BtnCalculate_Click(object sender, EventArgs e)
{
    int value = await CalculateValueAsync();
    LblResult.Text = value.ToString();
}
```

Еще пример. Используется `await` с WebClient:

```csharp
public async Task<int> CalculateValueAsync()
{
    await Task.Delay(5000);
    return 123;
}

private async void BtnCalculate_Click(object sender, EventArgs e)
{
    int value = await CalculateValueAsync();
    LblResult.Text = value.ToString();

    await Task.Delay(5000);

    using (var wc = new WebClient())
    {
        var data = await wc.DownloadStringTaskAsync("http://google.com/robots.txt");
        // Берется первая строка из полученного string
        LblResult.Text = data.Split('\n')[0].Trim();
    }
}
```

## Lesson 46. `Task.Run`

`Task.Run` - utility method in `Task` class.

* Вызов `Task.Run` эквивалентен вызову следующего метода:

```csharp
Task.Factory.StartNew(
    something,
    CancellationToken.None,
    TaskCreationOptions.DenyChildAttach,
    TaskScheduler.Deafult);
```

* Provides 8 overloads to support combinations of
  * `Task` vs `Task<T>`
  * Cancelable vs non-cancelable
  * Synchronous vs asynchronous delegate

### Work with asynchronous delegate. `Unwrap`

Пример. `Task`, который создает и запускает еще один `Task`:

```csharp
var t = Task.Factory.StartNew(() =>
{
    Task inner = Task.Factory.StartNew(() => {});
    return inner;
});
```

Возвращается `Task<Task>`.

Если изменить inner task на `() => 123`, то результатом будет `Task<Task<int>>`.

Пример. Передача в новый `Task` asynchronous delegate:

```csharp
var t = Task.Factory.StartNew(async () =>
{
    await Task.Delay(5000);
    return 123;
});
```

By marking the lambda as `async`:

* Compiler will map this delegate to be a `Func<Task<int>>`.
* Thus, the type of `t` is going to be `Task<Task<int>>`.

.NET 4 introduces `Unwrap()`:

```csharp
var t = Task.Factory.StartNew(async () =>
{
    await Task.Delay(5000);
    return 123;
}).Unwrap();
```

Causes the `t` variable to become `Task<int>`.

### Work with asynchronous delegate. `Task.Run()`

`Task.Run` is a shortcut that

* Calls `Task.Factory.StartNew()`.
* `Unwrap()`s the result.

It works correctly with either regular methods or async methods:

```csharp
int result = await Task.Run(async delegate
{
    await Task.Delay(1000);
    return 42;
});
```

The type of result is an `int` just as you would expect.

### Work with asynchronous delegate. `await`

`await` can be used as the language equivalent of `Unwrap()`.

```csharp
int result = await await Task.Factory.StartNew(async delegate
{
    await Task.Delay(1000);
    return 42;
},
CancellationToken.None,
TaskCreationOptions.DenyChildAttach,
TaskScheduler.Default);
```

Double `await`! We make a `Task<Task<int>>`, first await a `Task<int>`, second await coerces
it to an `int`.

## Lesson 47. Task Utility Combinators

Это utility методы которые:

* Kind of like `Task.WaitAll`/`WaitAny`.
* Create brand new tasks (useful for async/await!)
* `Task.WhenAny()`
* `Task.WhenAll()`

### `Task.WhenAny()`

Creates a task that will complete when *any* of the supplied tasks has completed.

```csharp
await Task.WhenAny(downloadFromHttp, downloadFromFtp);
```

### `Task.WhenAll()`

Creates a task that will complete when *all* of the supplied tasks has completed.

```csharp
await Task.WhenAll(measureTemperature, measurePressure);
```

## Lesson 48. Async Factory Method

Как выполнить асинхронную инициализацию, если конструктор не позволяет этого сделать?
Решение - использование async factory method.

```csharp
internal class Foo
{
    // Private ctor.
    private Foo()
    {
        Console.WriteLine($"ctor {nameof(Foo)}");
    }

    // Initialization method.
    private async Task<Foo> InitAsync()
    {
        Console.WriteLine("Initialization");
        await Task.Delay(1000);
        return this;
    }

    // Async factory method.
    public static Task<Foo> CreateAsync()
    {
        var result = new Foo();
        return result.InitAsync();
    }
}

internal static class Program
{
    private static async Task Main()
    {
        await Foo.CreateAsync();
    }
}
```

Вывод в консоль:

```text
ctor Foo
Initialization
```

Конструктор сделан private, чтобы не было возможности создать экземпляр класса `Foo` без
использования статического метода `CreateAsync()`.

## Lesson 49. Asynchronous Initialization Pattern

Если по каким-то причинам использование Async Factory Method не подходит, то можно сделать
специальный интерфейс, который будет сообщать всем, что класс, который его реализует, требует
асинхронной инициализации.

Пример. Интерфейс `IAsyncInit` служит "маркером" асинхронной инициализации класса:

```csharp
public  interface IAsyncInit
{
    Task InitTask { get; }
}

public class MyClass : IAsyncInit
{
    public MyClass()
    {
        Console.WriteLine($"Begin ctor {nameof(MyClass)}.");
        InitTask = InitAsync();
        Console.WriteLine($"End ctor {nameof(MyClass)}.");
    }

    public Task InitTask { get; }

    private async Task InitAsync()
    {
        Console.WriteLine($"Begin init {nameof(MyClass)}.");
        await Task.Delay(1000);
        Console.WriteLine($"End init {nameof(MyClass)}.");
    }
}

public class MyOtherClass : IAsyncInit
{
    private readonly MyClass _myClass;

    public MyOtherClass(MyClass myClass)
    {
        Console.WriteLine($"Begin ctor {nameof(MyOtherClass)}.");

        _myClass = myClass;
        InitTask = InitAsync();

        Console.WriteLine($"End ctor {nameof(MyOtherClass)}.");
    }

    public Task InitTask { get; }

    private async Task InitAsync()
    {
        Console.WriteLine($"Begin init {nameof(MyOtherClass)}.");

        if (_myClass is IAsyncInit ai)
            await ai.InitTask;

        await Task.Delay(1000);

        Console.WriteLine($"End init {nameof(MyOtherClass)}.");
    }
}

public static class Program
{
    private static async Task Main()
    {
        var myClass = new MyClass();
        var oc = new MyOtherClass(myClass);
        await oc.InitTask;
    }
}
```

Вывод:

```text
Begin ctor MyClass.
Begin init MyClass.
End ctor MyClass.
Begin ctor MyOtherClass.
Begin init MyOtherClass.
End ctor MyOtherClass.
End init MyClass.
End init MyOtherClass.
```

## Lesson 50. Asynchronous Lazy Initialization

Пример

```csharp
public class Stuff
{
    private readonly Lazy<Task<int>> LazyValue1 =
        new Lazy<Task<int>>(async () =>
        {
            Console.WriteLine($"Enter {nameof(LazyValue1)}");

            await Task.Delay(1000).ConfigureAwait(false);
            const int result = 1;

            Console.WriteLine($"Exit {nameof(LazyValue1)}");
            return result;
        });

    private readonly Lazy<Task<int>> LazyValue2 =
        new Lazy<Task<int>>(Task.Run(async() =>
        {
            Console.WriteLine($"Enter {nameof(LazyValue2)}");

            await Task.Delay(1000);
            const int result = 2;

            Console.WriteLine($"Exit {nameof(LazyValue2)}");
            return result;
        }));

    // Nito.AsyncEx
    private readonly AsyncLazy<int> LazyValue3 =
        new AsyncLazy<int>(async() =>
        {
            Console.WriteLine($"Enter {nameof(LazyValue3)}");

            await Task.Delay(1000);
            const int result = 3;

            Console.WriteLine($"Exit {nameof(LazyValue3)}");
            return result;
        });

    public async Task UseValues()
    {
        Console.WriteLine($"Use value 1 = {await LazyValue1.Value}");
        Console.WriteLine($"Use value 2 = {await LazyValue2.Value}");
        Console.WriteLine($"Use value 3 = {await LazyValue3}");
    }
}

public static class Program
{
    public static async Task Main()
    {
        var stuff = new Stuff();
        await stuff.UseValues();
    }
}
```

Вывод на консоль:

```Text
Enter LazyValue2
Enter LazyValue1
Exit LazyValue1
Exit LazyValue2
Use value 1 = 1
Use value 2 = 2
Enter LazyValue3
Exit LazyValue3
Use value 3 = 3
```

В качестве `LazyValue3` здесь приведен пример использования `AsyncLazy` из nuget пакета
`Nito.AsyncEx`. Его установка из CLI:

```text
dotnet add package Nito.AsyncEx --version 5.1.2
```
