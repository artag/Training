# Lesson 41. Property-based testing in F#

Как работают обычные тесты:

1. You manually create test data.
2. You push that test data through production code.
3. You confirm that the outputs of that code are as expected.

Как работают property-based тесты:

1. Machine *creates test data*, based on provided guidelines.
2. Test behaviors, or *properties* of the system that should hold true for *any* input values.
3. You can't hardcode the expected result of a test.

A property is a kind of relationship that you can test on the output of your production
code, without knowing the value of it.

### How to identify properties

Наиболее сложная часть of property-based testing это определение properties.

Примеры, каким образом можно задать properties:

1. *Identify specific properties about the behavior of the inputs and outputs*.

  * Например, есть функция `FlipCase`, которая превращает большие буквы в малые и наоборот.
  Для ее входов и выходов можно определить следующие свойства:
    * Same number of letters
    * No letter is the same case
    * Every letter is the same

2. *Identify a relationship between two functions*.

  * Можно одни и те же входные данные подать на две разные функции, и смотреть на взаимосвязь
  выходных данных. Например, две функции: вычитание двух чисел `sub` и сложение двух чисел
  `add`.

    ```fsharp
    let add a b =
        a + b

    let sub a b =
        a - b

    let c = add a b
    let d = sub a b
    ```

    Взаимосвязь двух этих функций: `c – d = b × 2`.

3. *Compare another implementation of the same function*.

  Если есть еще одна функция, которая выполняет те же действия, что и тестируемая, и которая
  гарантировано правильная, то можно сравнить результаты их работы между собой.

  Такое сравнение будет полезно при выполнении рефакторинга кода (тест разных версий кода).

### Introducing FsCheck

FsCheck is a property-testing library. NuGet package `FsCheck.Xunit` (also download the core
FsCheck package and xUnit).

FsCheck creates and runs 100 test cases by default.

### Running tests with FsCheck

В dotnet сделал тестовый проект на xUnit и смог запустить тесты из cli (`dotnet test`).

Пример теста, который выполняется:

```fsharp
// Логика для тестирования
let sumsNumbers numbers =
    numbers |> List.fold (+) 0

// Тест
[<Property(Verbose = true)>]
let ``Correctly add numbers`` numbers =
    let actual = sumNumbers numbers
    actual = List.sum numbers
```

Пример теста, который не выполняется:


```fsharp
// Логика для тестирования с ошибкой суммирования
let failedSumNumbers numbers =
    if numbers |> List.contains 5 then -1       // здесь ошибка
    else numbers |> List.fold (+) 0

// Тест
[<Property(Verbose = true)>]
let ``Incorrectly add numbers`` numbers =
    let actual = failedSumNumbers numbers
    actual = List.sum numbers
```

Этот тест после запуска выдаст примерно такую ошибку:

```text
FsCheck.Xunit.PropertyFailedException :
Falsifiable, after 10 tests (1 shrink) (StdGen (202261506, 296959544)):
Original:
[5; -1]
Shrunk:
[5]
```

* *Original* - the initial data that failed the test, randomly generated by FsCheck.
* *Shrunk* - a simplified dataset that fails the test based on the original data.
FsCheck оставляет здесь минимальный набор возможных данных, которые могут привести к ошибке
в тесте.

*Shrinking* is the process by which FsCheck reduces, or simplifies, a failing test dataset to
be the simplest possible failure case that it can be. This happens automatically and helps
identify how and why a test failed.

### Controlling data generation

```fsharp
// Логика для тестирования. Инверсия регистра букв
let flipCase (text:string) =
    text.ToCharArray()
    |> Array.map(fun c ->
        if Char.IsUpper c then Char.ToLower c
        else Char.ToUpper c)
    |> String

// Тест
[<Property>]
let ``Always has same number of letters`` (input:string) =
    let output = input |> Logic.flipCase
    input.Length = output.Length
```

Этот тест завершится с ошибкой, потому что в качестве входных значений будут использоваться
цифры, null значения. Конкретно здесь этот тест будет вылетать с ошибкой "NullReferenceException"
(на вход будет подаваться null).

Для задания ограничения ввода можно использовать guard clauses или генерировать ограниченные
наборы символов.

#### Guard clauses

Add a guard clause that says to prematurely exit any test where input is null:

```fsharp
open FsCheck        // Необходимо для определения оператора ==>

[<Property>]
let ``Always has same number of letters`` (input:string) =
    input <> null ==> lazy      // Adding a guard clause to an FsCheck property
        let output = input |> Logic.flipCase
        input.Length = output.Length
```

Custom `==>` operator says: "Run the code on the right only if the guard clause on the left
passes."

The `lazy` keyword is a language alias for `System.Lazy` and ensures that FsCheck runs the
test code only when the guard check has passed.

#### Generators and arbitrary values

When guard clauses aren't sufficient for your needs, you'll need to create a custom generator.
A *generator* allows you to specify a certain type of data, such as chars or strings,
which then map into arbitrary values that FsCheck can run in its tests.

FsCheck comes with many built-in arbitrary values in the `FsCheck.Arb.Default` module,
such as the usual lists, sets, and numbers, and even things like nonempty strings and IP addresses.

Creating a letters-only generator for FsCheck:

```fsharp
open System
open FsCheck

// Creating a class that contains arbitrary generators
// (1) - Creating a generator that creates a stream of letters
// unit -> Arbitrary<Char>
type LettersOnlyGen() =
    static member Letters() =
        Arb.Default.Char() |> Arb.filter Char.IsLetter      // (1)

// (2) - Attaching the generator to the property test
[<Property(Arbitrary = [| typeof<LettersOnlyGen> |])>]
let ``Always has same number of letters 2`` (NonEmptyString input) =
    let output = input |> flipCase
    input.Length = output.Length
```

`NonEmptyString` built-in discriminated union from FsCheck that garantees that input will never
be null.

Type `LettersOnlyGen` has a single static method `Letters`, that returns a type `Arbitrary<Char>`,
the type that controls which set of data FsCheck can use to pick from randomly. You can create
multiple generator methods with any name. No conventions exist, but you must have
only one method per type that you want to generate (for example, strings, integers, or customers).

In this case, you're creating the set of all characters, filtered by whether the character is
a letter. This is essentially the same as using `Seq.filter` or something similar, except
instead of operating on a real list of items, you supply the logic to FsCheck to tell it how
to generate data.

Next, you apply that generator to the test by setting the `Arbitrary` value of the `Property`
attribute. This ensures that all characters generated for this test are letters. And you can
replace the null-check guard by using the `NonEmptyString` discriminated union that was
previously mentioned, which FsCheck guarantees will never be null.

#### Детальный вывод генерируемых параметров для тестов

В атрибуте `Property` ставится параметр `Verbose = true`. И при запуске тестов в Visual Studio
будут показываться генерируемые FsCheck входные значения для тестирования.

Пример:

```fsharp
[<Property(Arbitrary = [| typeof<LettersOnlyGen> |], Verbose = true)>]
let ``Always has same number of letters`` (NonEmptyString input)
    // ...

[<Property(Verbose = true)>]
let ``Correctly add numbers`` numbers =
    // ...
```

Для .NET Core, чтобы увидеть эти генерируемые параметры, тесты надо запустить из консоли так:

```text
dotnet test --logger:"console;verbosity=detailed"
```
